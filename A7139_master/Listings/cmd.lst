C51 COMPILER V9.54   CMD                                                                   03/08/2017 16:52:07 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE CMD
OBJECT MODULE PLACED IN .\output\cmd.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\cmd\cmd.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\sour
                    -ce\USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\clock;.\so
                    -urce\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\cmd.lst) TABS(2) OBJECT(.\outp
                    -ut\cmd.obj)

line level    source

   1          #include "cmd.h"
   2          #include "uart.h"
   3          #include "clock.h"
   4          #include "A7139_comm.h"
   5          #include <ctype.h>
   6          #include <string.h>
   7          
   8          xdata uint8_t rf_tx_valid_flag = 0; 
   9          
  10          /* Display prompt string */
  11          code char *PROMPT =
  12             "\n#> "
  13             ;
  14          /* Copyright string */
  15          code char *COPYRIGHT =
  16           "\n"
  17           "SARI51 Copyright 2012-22"
  18             ;
  19          /* Local constants */
  20          code char *intro=
  21           "\n"
  22          // " SARI51 Command Line Interface"
  23           "SARI51 CLI"
  24             ;
  25          code char *help = 
  26           "\n"
  27               "+==== Command ===+= Function =============+\n"
  28          //   "|INFO            | Display system info    |\n"
  29          //   "|HELP or ?       | Display this help      |\n"
  30          //   "|----------------+------------------------|\n"
  31          //   "|LED [n] [op]    | Turn on/off led        |\n"
  32               "|TRAC            | Tracing Adjust Radio   |\n"
  33          //   "|XRAM [addr] <va>| Read/Write XRAM        |\n"
  34          //   "|REG  [reg] <va> | Read/Write SPI Register|\n"
  35               "|FREQ <va>       | Get/Set Frequency      |\n"
  36               "|COLC <va>       | Get/Set COLC           |\n"
  37               "|DIFF <va>       | Get/Set DesiredOffset  |\n"
  38               "|RATE <va>       | Get/Set RF Baudrate    |\n"
  39               "|TXPW <va>       | Get/Set RF TX Power    |\n"
  40          //   "|SEND            | Wireless Send Frame    |\n"
  41          //   "|RECV            | Wireless Receive Frame |\n"
  42               "|LOAD            | Read Flash Settings    |\n"
  43               "|SAVE            | Save to Flash          |\n"
  44               "+----------------+------------------------+"
  45             ;
  46          
  47          static void cmd_help (char *par) 
  48          {
  49   1        par=par;
  50   1        printf(help);
  51   1        return;
  52   1      }
C51 COMPILER V9.54   CMD                                                                   03/08/2017 16:52:07 PAGE 2   

  53          
  54          static void cmd_tx (char *par) 
  55          {
  56   1        rf_tx_valid_flag = 1;
  57   1      }
*** WARNING C280 IN LINE 54 OF source\USER\cmd\cmd.c: 'par': unreferenced local variable
  58          
  59          code CMD_TYPE cmd[] = {
  60          //  "RECV", cmd_recv,
  61          //  "XRAM", cmd_xram,
  62          //  "REG",  cmd_reg,
  63            //"FREQ", cmd_freq,
  64            //"COLC", cmd_colc,
  65            //"DIFF", cmd_diff,
  66            ////"RATE", cmd_rate,
  67            //"TXPW", cmd_txpower,
  68          //  "SEND", cmd_send,
  69            //"LED",  cmd_led,
  70            //"TRAC", cmd_trace,
  71            //"LOAD", cmd_load,
  72            //"SAVE", cmd_save,
  73            //"INFO", cmd_info,
  74            "HELP", cmd_help,
  75            //"?",    cmd_help
  76            "TX", cmd_tx,
  77            };
  78            
  79          #define CMD_COUNT   (sizeof (cmd) / sizeof (cmd[0]))
  80          
  81          //xdata char in_line[CMD_BUF_LEN_MAX] = { 0 };
  82          xdata uint8_t in_line[CMD_BUF_LEN_MAX] = { 0 };
  83          
  84          extern uint8_t xdata a7139_tx[RF_RECV_BUF_LEN_MAX];
  85          
  86          int getline(uint8_t * lp, uint8_t n)
  87          {
  88   1          uint8_t cnt = 0;
  89   1          uint8_t c;
  90   1          uint8_t pos = 0;
  91   1          uint8_t head1 = 0;
  92   1        
  93   1          if( avalible() > 0 )
  94   1          {
  95   2            do 
  96   2            {
  97   3                //clock_delay(CMD_GET_LINE_DELAY);
  98   3                c = uart_getchar();
  99   3                switch(c) 
 100   3                {
 101   4                     case CMD_FLAG_ZERO:
 102   4                         if( 1 == head1 )
 103   4                         {
 104   5                           return (TRUE);
 105   5                         }
 106   4                     break;
 107   4                     case CMD_FLAG_CNTL_Q:   /* ignore Control S/Q             */
 108   4                     case CMD_FLAG_CNTL_S:
 109   4                     break;
 110   4                    
 111   4                     case CMD_FLAG_BACKSPACE:
 112   4                     case CMD_FLAG_DEL:
 113   4                        if (cnt == 0) {
C51 COMPILER V9.54   CMD                                                                   03/08/2017 16:52:07 PAGE 3   

 114   5                           break;
 115   5                        }
 116   4                        cnt--;                         /* decrement count                */
 117   4                        lp--;                          /* and line pointer               */
 118   4                        putchar (0x08);                /* echo backspace                 */
 119   4                        putchar (' ');
 120   4                        putchar (0x08);
 121   4                        break;
 122   4                     case CMD_FLAG_PKT_HEAD_1:
 123   4                        head1 = 1;
 124   4                        *lp = c;
 125   4                        a7139_tx[pos] = c;
 126   4                        pos++;
 127   4                        lp++;                          /* increment line pointer         */
 128   4                        cnt++;
 129   4                        break;
 130   4                     case CMD_FLAG_PKT_HEAD_2:
 131   4                        if( 1 == head1 )
 132   4                        {
 133   5                           uint8_t i = 0;
 134   5                          
 135   5                           *lp = c;
 136   5                           a7139_tx[pos] = c;
 137   5                           pos++;
 138   5                           lp++;                          /* increment line pointer         */
 139   5                           cnt++;
 140   5                          
 141   5                           for(i = 0; i < 5; i++)  // RF_RECV_BUF_LEN_MAX - 2
 142   5                           {
 143   6                              *lp = uart_getchar();
 144   6                              a7139_tx[pos] = *lp;
 145   6                              pos++;
 146   6                              lp++;                          /* increment line pointer         */
 147   6                              cnt++; 
 148   6                           }
 149   5                           
 150   5                           cmd_tx(NULL);
 151   5                           
 152   5                           return (TRUE);
 153   5                        }
 154   4                        
 155   4                        break;
 156   4                     case CMD_FLAG_ESC:
 157   4                        *lp = 0;                       /* ESC - stop editing line        */
 158   4                        return (FALSE);
 159   4                     case CMD_FLAG_CR:                          /* CR - done, stop editing line   */
 160   4                        *lp = c;
 161   4                        lp++;                          /* increment line pointer         */
 162   4                        cnt++;                         /* and count                      */
 163   4                        c = CMD_FLAG_LF;
 164   4                     default:
 165   4                        *lp = c;
 166   4                        //putchar (c); 
 167   4                        putchar (*lp);             /* echo and store character       */
 168   4                        
 169   4                        lp++;                          /* increment line pointer         */
 170   4                        cnt++;                         /* and count                      */
 171   4                        break;
 172   4              }
 173   3           } while (cnt < n - 2  &&  c != CMD_FLAG_LF);     /* check limit and CR             */
 174   2         }
 175   1          
C51 COMPILER V9.54   CMD                                                                   03/08/2017 16:52:07 PAGE 4   

 176   1         *lp = 0;    
 177   1                                  /* mark end of string             */
 178   1         return (TRUE);
 179   1      }
 180          
 181          
 182          #if 0
              int getline(char * lp, uint32_t n)
              {
                  uint32_t cnt = 0;
                  char c;
              
                  uint8_t head1 = 0;
                
                  if( avalible() > 0 )
                  {
                    do 
                    {
                        //clock_delay(CMD_GET_LINE_DELAY);
                        c = getchar();
                        putchar(c);
                        putchar(" ");
                        switch(c) 
                        {
                             case CMD_FLAG_ZERO:
                             case CMD_FLAG_CNTL_Q:   /* ignore Control S/Q             */
                             case CMD_FLAG_CNTL_S:
                             break;
                            
                             case CMD_FLAG_BACKSPACE:
                             case CMD_FLAG_DEL:
                                if (cnt == 0) {
                                   break;
                                }
                                cnt--;                         /* decrement count                */
                                lp--;                          /* and line pointer               */
                                putchar (0x08);                /* echo backspace                 */
                                putchar (' ');
                                putchar (0x08);
                                break;
                             case CMD_FLAG_PKT_HEAD_1:
                                head1 = 1;
                                *lp = c;
                                lp++;                          /* increment line pointer         */
                                cnt++;
                                break;
                             case CMD_FLAG_PKT_HEAD_2:
                                if( 1 == head1 )
                                {
                                   uint8_t i = 0;
                                  
                                   *lp = c;
                                   lp++;                          /* increment line pointer         */
                                   cnt++;
                                  
                                   for(i = 0; i < 5; i++)  // RF_RECV_BUF_LEN_MAX - 2
                                   {
                                      *lp = getchar();
                                      lp++;                          /* increment line pointer         */
                                      cnt++; 
                                   }
                                   
C51 COMPILER V9.54   CMD                                                                   03/08/2017 16:52:07 PAGE 5   

                                   cmd_tx(NULL);
                                   
                                   return (TRUE);
                                }
                                
                                break;
                             case CMD_FLAG_ESC:
                                *lp = 0;                       /* ESC - stop editing line        */
                                return (FALSE);
                             case CMD_FLAG_CR:                          /* CR - done, stop editing line   */
                                *lp = c;
                                lp++;                          /* increment line pointer         */
                                cnt++;                         /* and count                      */
                                c = CMD_FLAG_LF;
                             default:
                                *lp = c;
                                //putchar (c); 
                                putchar (*lp);             /* echo and store character       */
                                
                                lp++;                          /* increment line pointer         */
                                cnt++;                         /* and count                      */
                                break;
                      }
                   } while (cnt < n - 2  &&  c != CMD_FLAG_LF);     /* check limit and CR             */
                 }
                  
                 *lp = 0;    
                                          /* mark end of string             */
                 return (TRUE);
              }
              
              #endif
 270          
 271          int strtoul(char *s)
 272          {
 273   1        int ret;
 274   1        int radix = 10;
 275   1        int negative = 0;
 276   1        int i;
 277   1        ret = 0;
 278   1        if(*s == '-') 
 279   1        {
 280   2          negative = 1;
 281   2          s++;
 282   2        }
 283   1        else if(*s == '0')
 284   1        {
 285   2          s++;
 286   2          if(*s == 'x')
 287   2          {
 288   3            s++;
 289   3            radix = 0x10;
 290   3          }
 291   2        }
 292   1        while (*s) {
 293   2          if (*s >= '0' && *s <= '9')
 294   2            i = *s - '0';
 295   2          else if (*s >= 'a' && *s <= 'f')
 296   2            i = *s - 'a' + 0xa;
 297   2          else if (*s >= 'A' && *s <= 'F')
 298   2            i = *s - 'A' + 0xa;
 299   2          else
C51 COMPILER V9.54   CMD                                                                   03/08/2017 16:52:07 PAGE 6   

 300   2            break;
 301   2          if(i >= radix) break;
 302   2          ret = (ret * radix) + i;
 303   2          s++;
 304   2        }
 305   1        return negative?(-ret):ret;
 306   1      }
 307          
 308          char *getentry(char *cp, char **ppNext)
 309          {
 310   1        char *sp, lfn = 0, sep_ch = ' ';
 311   1         if (cp == NULL) {                          /* skip NULL pointers          */
 312   2            *ppNext = cp;
 313   2            return (cp);
 314   2         }
 315   1         for ( ; *cp == ' ' || *cp == '\"'; cp++) { /* skip blanks and starting  " */
 316   2            if (*cp == '\"') { sep_ch = '\"'; lfn = 1; }
 317   2            *cp = 0;
 318   2         }
 319   1         for (sp = cp; *sp != CMD_FLAG_CR && *sp != CMD_FLAG_LF; sp++) {
 320   2            if ( lfn && *sp == '\"') break;
 321   2            if (!lfn && *sp == ' ' ) break;
 322   2         }
 323   1         for ( ; *sp == sep_ch || *sp == CMD_FLAG_CR || *sp == CMD_FLAG_LF; sp++) {
 324   2            *sp = 0;
 325   2            if ( lfn && *sp == sep_ch) { sp ++; break; }
 326   2         }
 327   1         *ppNext = (*sp) ? sp : NULL;                /* next entry                  */
 328   1         return (cp);
 329   1      }
 330          
 331          int cmd_master(void)
 332          {
 333   1         int ret = TRUE;
 334   1         char *sp=NULL,*cp=NULL,*next=NULL;
 335   1         int8_t i;
 336   1         unsigned char u = 0;
 337   1         //printf (intro);                            /* display example info        */
 338   1         //printf (help);
 339   1         //cmd[0].func(NULL); //?????recv??
 340   1            //printf (PROMPT);                     /* display prompt              */
 341   1            /* get command line input      */
 342   1          ret = getline (in_line, CMD_BUF_LEN_MAX);
 343   1          if( FALSE == ret ) 
 344   1          {
 345   2            printf("get line failed\n");
 346   2          }
 347   1          else
 348   1          {
 349   2            //printf("getline %s\n", in_line);
 350   2            sp = getentry (&in_line[0], &next);
 351   2            if (*sp != 0) 
 352   2            {
 353   3               for (cp = sp; *cp && (*cp != ' '); cp++) {
 354   4               *cp = toupper (*cp);                 /* command to upper-case       */
 355   4              }
 356   3               
 357   3              for (i = 0; i < CMD_COUNT; i++) 
 358   3              {
 359   4                 if (0 == strcmp (sp, (const char *)&cmd[i].name)) 
 360   4                 {
 361   5                    cmd[i].func (next);                  /* execute command function    */
C51 COMPILER V9.54   CMD                                                                   03/08/2017 16:52:07 PAGE 7   

 362   5                    break;
 363   5                 }
 364   4                 
 365   4              }
 366   3              
 367   3              if (i == CMD_COUNT) {
 368   4                ret = FALSE;
 369   4                printf ("\ncmd error\n");
 370   4              }
 371   3            }
 372   2          }
 373   1          
 374   1          return ret;
 375   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2236    ----
   CONSTANT SIZE    =    547    ----
   XDATA SIZE       =     83    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
