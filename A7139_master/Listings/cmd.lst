C51 COMPILER V9.54   CMD                                                                   03/09/2017 18:13:18 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE CMD
OBJECT MODULE PLACED IN .\output\cmd.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\cmd\cmd.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\sour
                    -ce\USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\clock;.\so
                    -urce\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\cmd.lst) TABS(2) OBJECT(.\outp
                    -ut\cmd.obj)

line level    source

   1          #include "cmd.h"
   2          #include "uart.h"
   3          #include "clock.h"
   4          #include "A7139_comm.h"
   5          #include <ctype.h>
   6          #include <string.h>
   7          
   8          xdata uint8_t rf_tx_valid_flag = 0; 
   9          
  10          /* Display prompt string */
  11          code char *PROMPT =
  12             "\n#> "
  13             ;
  14          /* Copyright string */
  15          code char *COPYRIGHT =
  16           "\n"
  17           "SARI51 Copyright 2012-22"
  18             ;
  19          /* Local constants */
  20          code char *intro=
  21           "\n"
  22          // " SARI51 Command Line Interface"
  23           "SARI51 CLI"
  24             ;
  25          code char *help = 
  26           "\n"
  27               "+==== Command ===+= Function =============+\n"
  28          //   "|INFO            | Display system info    |\n"
  29          //   "|HELP or ?       | Display this help      |\n"
  30          //   "|----------------+------------------------|\n"
  31          //   "|LED [n] [op]    | Turn on/off led        |\n"
  32               "|TRAC            | Tracing Adjust Radio   |\n"
  33          //   "|XRAM [addr] <va>| Read/Write XRAM        |\n"
  34          //   "|REG  [reg] <va> | Read/Write SPI Register|\n"
  35               "|FREQ <va>       | Get/Set Frequency      |\n"
  36               "|COLC <va>       | Get/Set COLC           |\n"
  37               "|DIFF <va>       | Get/Set DesiredOffset  |\n"
  38               "|RATE <va>       | Get/Set RF Baudrate    |\n"
  39               "|TXPW <va>       | Get/Set RF TX Power    |\n"
  40          //   "|SEND            | Wireless Send Frame    |\n"
  41          //   "|RECV            | Wireless Receive Frame |\n"
  42               "|LOAD            | Read Flash Settings    |\n"
  43               "|SAVE            | Save to Flash          |\n"
  44               "+----------------+------------------------+"
  45             ;
  46          
  47          static void cmd_help (char *par) 
  48          {
  49   1        par=par;
  50   1        printf(help);
  51   1        return;
  52   1      }
C51 COMPILER V9.54   CMD                                                                   03/09/2017 18:13:18 PAGE 2   

  53          
  54          static void cmd_tx (char *par) 
  55          {
  56   1        rf_tx_valid_flag = 1;
  57   1      }
*** WARNING C280 IN LINE 54 OF source\USER\cmd\cmd.c: 'par': unreferenced local variable
  58          
  59          code CMD_TYPE cmd[] = {
  60          //  "RECV", cmd_recv,
  61          //  "XRAM", cmd_xram,
  62          //  "REG",  cmd_reg,
  63            //"FREQ", cmd_freq,
  64            //"COLC", cmd_colc,
  65            //"DIFF", cmd_diff,
  66            ////"RATE", cmd_rate,
  67            //"TXPW", cmd_txpower,
  68          //  "SEND", cmd_send,
  69            //"LED",  cmd_led,
  70            //"TRAC", cmd_trace,
  71            //"LOAD", cmd_load,
  72            //"SAVE", cmd_save,
  73            //"INFO", cmd_info,
  74            "HELP", cmd_help,
  75            //"?",    cmd_help
  76            "TX", cmd_tx,
  77            };
  78            
  79          #define CMD_COUNT   (sizeof (cmd) / sizeof (cmd[0]))
  80          
  81          //xdata char in_line[CMD_BUF_LEN_MAX] = { 0 };
  82          xdata uint8_t in_line[CMD_BUF_LEN_MAX] = { 0 };
  83          extern uint16_t xdata per_tick_flag;
  84          extern uint8_t xdata a7139_tx[RF_RECV_BUF_LEN_MAX];
  85          
  86          int getline(uint8_t * lp, uint8_t n)
  87          {
  88   1          uint8_t cnt = 0;
  89   1          uint8_t c;
  90   1          uint8_t pos = 0;
  91   1          uint8_t head1 = 0;
  92   1          int wait_overtime_flag = 0;
  93   1          if( avalible() > 0 )
  94   1          {
  95   2            do 
  96   2            {
  97   3                //clock_delay(CMD_GET_LINE_DELAY);
  98   3              c = uart_getchar();
  99   3                  switch(c) 
 100   3                  {
 101   4                       case CMD_FLAG_ZERO:
 102   4                       break;
 103   4                       case CMD_FLAG_CNTL_Q:   /* ignore Control S/Q             */
 104   4                       case CMD_FLAG_CNTL_S:
 105   4                       break;
 106   4                      
 107   4                       case CMD_FLAG_BACKSPACE:
 108   4                       case CMD_FLAG_DEL:
 109   4                          if (cnt == 0) {
 110   5                             break;
 111   5                          }
 112   4                          cnt--;                         /* decrement count                */
 113   4                          lp--;                          /* and line pointer               */
C51 COMPILER V9.54   CMD                                                                   03/09/2017 18:13:18 PAGE 3   

 114   4                          putchar (0x08);                /* echo backspace                 */
 115   4                          putchar (' ');
 116   4                          putchar (0x08);
 117   4                          break;
 118   4                       case CMD_FLAG_PKT_HEAD_1:
 119   4                          head1 = 1;
 120   4                          *lp = c;
 121   4                          a7139_tx[pos] = c;
 122   4                          pos++;
 123   4                          lp++;                          /* increment line pointer         */
 124   4                          cnt++;
 125   4                          break;
 126   4                       
 127   4                       case CMD_FLAG_ESC:
 128   4                          *lp = 0;                       /* ESC - stop editing line        */
 129   4                          return (FALSE);
 130   4                       case CMD_FLAG_CR:                          /* CR - done, stop editing line   */
 131   4                          *lp = c;
 132   4                          lp++;                          /* increment line pointer         */
 133   4                          cnt++;                         /* and count                      */
 134   4                          c = CMD_FLAG_LF;
 135   4                       default:
 136   4                        if(head1)
 137   4                        {
 138   5                          uint8_t i = 0;
 139   5                          uint8_t len = 0;
 140   5                          uint16_t wait_flag = 0;
 141   5                          *lp = c;
 142   5                          a7139_tx[pos] = c;
 143   5                          len = c;
 144   5                          pos++;
 145   5                          lp++;                          /* increment line pointer         */
 146   5                          cnt++;
 147   5                          wait_flag = per_tick_flag;
 148   5                          for(i = 0; i < len+1; )  // RF_RECV_BUF_LEN_MAX - 2
 149   5                          {
 150   6                            if(avalible() > 0){
 151   7                            *lp = uart_getchar();
 152   7                            a7139_tx[pos] = *lp;
 153   7                            pos++;
 154   7                            i++;
 155   7                            lp++;                          /* increment line pointer         */
 156   7                            cnt++;} 
 157   6                            if((wait_flag + CLOCK_CONF_SECOND) == per_tick_flag)
 158   6                            {
 159   7                              wait_overtime_flag = 1;
 160   7                              break;
 161   7                            }
 162   6                          }
 163   5                          if(wait_overtime_flag)
 164   5                          {
 165   6                            pos = 0;
 166   6                            head1=0;
 167   6                            return (FALSE);
 168   6                          }
 169   5                          else
 170   5                          { 
 171   6                            if(a7139_tx[pos-1]==chkSumCalc(&a7139_tx[1],pos-2))
 172   6                            {
 173   7                              cmd_tx(NULL);
 174   7                              return (TRUE);
 175   7                            }
C51 COMPILER V9.54   CMD                                                                   03/09/2017 18:13:18 PAGE 4   

 176   6                            else
 177   6                              return (FALSE);
 178   6                          }                 
 179   5                        }else{
 180   5                          *lp = c;  
 181   5                          lp++;                          /* increment line pointer         */
 182   5                          cnt++;}                         /* and count                      */
 183   4                          break;
 184   4                }       
 185   3           } while (cnt < n - 2  &&  c != CMD_FLAG_LF);     /* check limit and CR             */
 186   2         }
 187   1          
 188   1         *lp = 0;    
 189   1                                  /* mark end of string             */
 190   1         return (TRUE);
 191   1      }
 192          
 193          
 194          int strtoul(char *s)
 195          {
 196   1        int ret;
 197   1        int radix = 10;
 198   1        int negative = 0;
 199   1        int i;
 200   1        ret = 0;
 201   1        if(*s == '-') 
 202   1        {
 203   2          negative = 1;
 204   2          s++;
 205   2        }
 206   1        else if(*s == '0')
 207   1        {
 208   2          s++;
 209   2          if(*s == 'x')
 210   2          {
 211   3            s++;
 212   3            radix = 0x10;
 213   3          }
 214   2        }
 215   1        while (*s) {
 216   2          if (*s >= '0' && *s <= '9')
 217   2            i = *s - '0';
 218   2          else if (*s >= 'a' && *s <= 'f')
 219   2            i = *s - 'a' + 0xa;
 220   2          else if (*s >= 'A' && *s <= 'F')
 221   2            i = *s - 'A' + 0xa;
 222   2          else
 223   2            break;
 224   2          if(i >= radix) break;
 225   2          ret = (ret * radix) + i;
 226   2          s++;
 227   2        }
 228   1        return negative?(-ret):ret;
 229   1      }
 230          
 231          char *getentry(char *cp, char **ppNext)
 232          {
 233   1        char *sp, lfn = 0, sep_ch = ' ';
 234   1         if (cp == NULL) {                          /* skip NULL pointers          */
 235   2            *ppNext = cp;
 236   2            return (cp);
 237   2         }
C51 COMPILER V9.54   CMD                                                                   03/09/2017 18:13:18 PAGE 5   

 238   1         for ( ; *cp == ' ' || *cp == '\"'; cp++) { /* skip blanks and starting  " */
 239   2            if (*cp == '\"') { sep_ch = '\"'; lfn = 1; }
 240   2            *cp = 0;
 241   2         }
 242   1         for (sp = cp; *sp != CMD_FLAG_CR && *sp != CMD_FLAG_LF; sp++) {
 243   2            if ( lfn && *sp == '\"') break;
 244   2            if (!lfn && *sp == ' ' ) break;
 245   2         }
 246   1         for ( ; *sp == sep_ch || *sp == CMD_FLAG_CR || *sp == CMD_FLAG_LF; sp++) {
 247   2            *sp = 0;
 248   2            if ( lfn && *sp == sep_ch) { sp ++; break; }
 249   2         }
 250   1         *ppNext = (*sp) ? sp : NULL;                /* next entry                  */
 251   1         return (cp);
 252   1      }
 253          
 254          int cmd_master(void)
 255          {
 256   1         int ret = TRUE;
 257   1         char *sp=NULL,*cp=NULL,*next=NULL;
 258   1         int8_t i;
 259   1         unsigned char u = 0;
 260   1         //printf (intro);                            /* display example info        */
 261   1         //printf (help);
 262   1         //printf (PROMPT);                     /* display prompt              */
 263   1            /* get command line input      */
 264   1          ret = getline (in_line, CMD_BUF_LEN_MAX);
 265   1          if( FALSE == ret ) 
 266   1          {
 267   2            printf("get line failed\n");
 268   2          }
 269   1          else
 270   1          {
 271   2            sp = getentry (&in_line[0], &next);
 272   2            if (*sp != 0) 
 273   2            {
 274   3               for (cp = sp; *cp && (*cp != ' '); cp++) {
 275   4               *cp = toupper (*cp);                 /* command to upper-case       */
 276   4              }
 277   3               
 278   3              for (i = 0; i < CMD_COUNT; i++) 
 279   3              {
 280   4                 if (0 == strcmp (sp, (const char *)&cmd[i].name)) 
 281   4                 {
 282   5                    cmd[i].func (next);                  /* execute command function    */
 283   5                    break;
 284   5                 }
 285   4                 
 286   4              }
 287   3              
 288   3              if (i == CMD_COUNT) {
 289   4                ret = FALSE;
 290   4                if(!rf_tx_valid_flag)
 291   4                printf ("\ncmd error\n");
 292   4              }
 293   3            }
 294   2          }
 295   1          
 296   1          return ret;
 297   1      }


C51 COMPILER V9.54   CMD                                                                   03/09/2017 18:13:18 PAGE 6   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2410    ----
   CONSTANT SIZE    =    547    ----
   XDATA SIZE       =     88    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
