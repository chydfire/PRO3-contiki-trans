C51 COMPILER V9.54   CMD                                                                   03/07/2017 19:19:57 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE CMD
OBJECT MODULE PLACED IN .\output\cmd.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\cmd\cmd.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\sour
                    -ce\USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\clock;.\so
                    -urce\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\cmd.lst) TABS(2) OBJECT(.\outp
                    -ut\cmd.obj)

line level    source

   1          #include "cmd.h"
   2          #include "uart.h"
   3          #include "clock.h"
   4          #include <ctype.h>
   5          #include <string.h>
   6          
   7          /* Display prompt string */
   8          code char *PROMPT =
   9             "\n#> "
  10             ;
  11          /* Copyright string */
  12          code char *COPYRIGHT =
  13           "\n"
  14           "SARI51 Copyright 2012-22"
  15             ;
  16          /* Local constants */
  17          code char *intro=
  18           "\n"
  19          // " SARI51 Command Line Interface"
  20           "SARI51 CLI"
  21             ;
  22          code char *help = 
  23           "\n"
  24               "+==== Command ===+= Function =============+\n"
  25          //   "|INFO            | Display system info    |\n"
  26          //   "|HELP or ?       | Display this help      |\n"
  27          //   "|----------------+------------------------|\n"
  28          //   "|LED [n] [op]    | Turn on/off led        |\n"
  29               "|TRAC            | Tracing Adjust Radio   |\n"
  30          //   "|XRAM [addr] <va>| Read/Write XRAM        |\n"
  31          //   "|REG  [reg] <va> | Read/Write SPI Register|\n"
  32               "|FREQ <va>       | Get/Set Frequency      |\n"
  33               "|COLC <va>       | Get/Set COLC           |\n"
  34               "|DIFF <va>       | Get/Set DesiredOffset  |\n"
  35               "|RATE <va>       | Get/Set RF Baudrate    |\n"
  36               "|TXPW <va>       | Get/Set RF TX Power    |\n"
  37          //   "|SEND            | Wireless Send Frame    |\n"
  38          //   "|RECV            | Wireless Receive Frame |\n"
  39               "|LOAD            | Read Flash Settings    |\n"
  40               "|SAVE            | Save to Flash          |\n"
  41               "+----------------+------------------------+"
  42             ;
  43          
  44          static void cmd_help (char *par) 
  45          {
  46   1        par=par;
  47   1        printf(help);
  48   1        return;
  49   1      }
  50          
  51          code CMD_TYPE cmd[] = {
  52          //  "RECV", cmd_recv,
C51 COMPILER V9.54   CMD                                                                   03/07/2017 19:19:57 PAGE 2   

  53          //  "XRAM", cmd_xram,
  54          //  "REG",  cmd_reg,
  55            //"FREQ", cmd_freq,
  56            //"COLC", cmd_colc,
  57            //"DIFF", cmd_diff,
  58            ////"RATE", cmd_rate,
  59            //"TXPW", cmd_txpower,
  60          //  "SEND", cmd_send,
  61            //"LED",  cmd_led,
  62            //"TRAC", cmd_trace,
  63            //"LOAD", cmd_load,
  64            //"SAVE", cmd_save,
  65            //"INFO", cmd_info,
  66            "HELP", cmd_help,
  67            //"?",    cmd_help
  68            };
  69            
  70          #define CMD_COUNT   (sizeof (cmd) / sizeof (cmd[0]))
  71            
  72          char in_line[CMD_BUF_LEN_MAX] = { 0 };
  73          
  74          int getline(char * lp, uint32_t n)
  75          {
  76   1          uint32_t cnt = 0;
  77   1          char c;
  78   1        
  79   1          do 
  80   1          {
  81   2              //clock_delay(CMD_GET_LINE_DELAY);
  82   2              c = getchar();
  83   2              switch(c) 
  84   2              {
  85   3                   case CMD_FLAG_ZERO:
  86   3                   case CMD_FLAG_CNTL_Q:   /* ignore Control S/Q             */
  87   3                   case CMD_FLAG_CNTL_S:
  88   3                   break;
  89   3                  
  90   3                   case CMD_FLAG_BACKSPACE:
  91   3                   case CMD_FLAG_DEL:
  92   3                      if (cnt == 0) {
  93   4                         break;
  94   4                      }
  95   3                      cnt--;                         /* decrement count                */
  96   3                      lp--;                          /* and line pointer               */
  97   3                      putchar (0x08);                /* echo backspace                 */
  98   3                      putchar (' ');
  99   3                      putchar (0x08);
 100   3                      break;
 101   3                   case CMD_FLAG_ESC:
 102   3                      *lp = 0;                       /* ESC - stop editing line        */
 103   3                      return (FALSE);
 104   3                   case CMD_FLAG_CR:                          /* CR - done, stop editing line   */
 105   3                      *lp = c;
 106   3                      lp++;                          /* increment line pointer         */
 107   3                      cnt++;                         /* and count                      */
 108   3                      c = CMD_FLAG_LF;
 109   3                   default:
 110   3                      *lp = c;
 111   3                      //putchar (c); 
 112   3                      putchar (*lp);             /* echo and store character       */
 113   3                      
 114   3                      lp++;                          /* increment line pointer         */
C51 COMPILER V9.54   CMD                                                                   03/07/2017 19:19:57 PAGE 3   

 115   3                      cnt++;                         /* and count                      */
 116   3                      break;
 117   3            }
 118   2         } while (cnt < n - 2  &&  c != CMD_FLAG_LF);     /* check limit and CR             */
 119   1         *lp = 0;    
 120   1                                  /* mark end of string             */
 121   1         return (TRUE);
 122   1      }
 123          
 124          int strtoul(char *s)
 125          {
 126   1        int ret;
 127   1        int radix = 10;
 128   1        int negative = 0;
 129   1        int i;
 130   1        ret = 0;
 131   1        if(*s == '-') 
 132   1        {
 133   2          negative = 1;
 134   2          s++;
 135   2        }
 136   1        else if(*s == '0')
 137   1        {
 138   2          s++;
 139   2          if(*s == 'x')
 140   2          {
 141   3            s++;
 142   3            radix = 0x10;
 143   3          }
 144   2        }
 145   1        while (*s) {
 146   2          if (*s >= '0' && *s <= '9')
 147   2            i = *s - '0';
 148   2          else if (*s >= 'a' && *s <= 'f')
 149   2            i = *s - 'a' + 0xa;
 150   2          else if (*s >= 'A' && *s <= 'F')
 151   2            i = *s - 'A' + 0xa;
 152   2          else
 153   2            break;
 154   2          if(i >= radix) break;
 155   2          ret = (ret * radix) + i;
 156   2          s++;
 157   2        }
 158   1        return negative?(-ret):ret;
 159   1      }
 160          
 161          char *getentry(char *cp, char **ppNext)
 162          {
 163   1        char *sp, lfn = 0, sep_ch = ' ';
 164   1         if (cp == NULL) {                          /* skip NULL pointers          */
 165   2            *ppNext = cp;
 166   2            return (cp);
 167   2         }
 168   1         for ( ; *cp == ' ' || *cp == '\"'; cp++) { /* skip blanks and starting  " */
 169   2            if (*cp == '\"') { sep_ch = '\"'; lfn = 1; }
 170   2            *cp = 0;
 171   2         }
 172   1         for (sp = cp; *sp != CMD_FLAG_CR && *sp != CMD_FLAG_LF; sp++) {
 173   2            if ( lfn && *sp == '\"') break;
 174   2            if (!lfn && *sp == ' ' ) break;
 175   2         }
 176   1         for ( ; *sp == sep_ch || *sp == CMD_FLAG_CR || *sp == CMD_FLAG_LF; sp++) {
C51 COMPILER V9.54   CMD                                                                   03/07/2017 19:19:57 PAGE 4   

 177   2            *sp = 0;
 178   2            if ( lfn && *sp == sep_ch) { sp ++; break; }
 179   2         }
 180   1         *ppNext = (*sp) ? sp : NULL;                /* next entry                  */
 181   1         return (cp);
 182   1      }
 183          
 184          void cmdline(void)
 185          {
 186   1         char *sp=NULL,*cp=NULL,*next=NULL;
 187   1         int8_t i;
 188   1         unsigned char u = 0;
 189   1        char c;
 190   1         //printf (intro);                            /* display example info        */
 191   1         //printf (help);
 192   1         //cmd[0].func(NULL); //?????recv??
 193   1         while (TRUE) {
 194   2            //printf (PROMPT);                     /* display prompt              */
 195   2            /* get command line input      */
 196   2           #if 0
                    do
                    {
                      c = getchar();
                      if( 0 != c )
                      {
                        putchar( c );
                      }
                    }while( 0 != c );
                    #endif
 206   2            #if 1
 207   2            if (getline (in_line, CMD_BUF_LEN_MAX) == FALSE) {
 208   3              printf("get line failed\n");
 209   3               continue;
 210   3            }
 211   2      //      for(u = 0; u < 32; u++){
 212   2      //      putchar(in_line[u]);
 213   2      //      }
 214   2      //      putchar("\n");
 215   2            printf("getline %s\n", in_line);
 216   2            #endif
 217   2            #if 1
 218   2            sp = getentry (&in_line[0], &next);
 219   2            if (*sp == 0) {
 220   3               continue;
 221   3            }
 222   2            for (cp = sp; *cp && (*cp != ' '); cp++) {
 223   3               *cp = toupper (*cp);                 /* command to upper-case       */
 224   3            }
 225   2            for (i = 0; i < CMD_COUNT; i++) {
 226   3               if (strcmp (sp, (const char *)&cmd[i].name)) {
 227   4                  continue;
 228   4               }
 229   3               cmd[i].func (next);                  /* execute command function    */
 230   3               break;
 231   3            }
 232   2            if (i == CMD_COUNT) {
 233   3              printf ("\ncmd error\n");
 234   3            }
 235   2            #endif
 236   2         }
 237   1      }
*** WARNING C280 IN LINE 189 OF source\USER\cmd\cmd.c: 'c': unreferenced local variable
C51 COMPILER V9.54   CMD                                                                   03/07/2017 19:19:57 PAGE 5   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2070    ----
   CONSTANT SIZE    =    548    ----
   XDATA SIZE       =     81    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
