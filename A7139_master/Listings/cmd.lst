C51 COMPILER V9.54   CMD                                                                   03/08/2017 15:17:00 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE CMD
OBJECT MODULE PLACED IN .\output\cmd.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\cmd\cmd.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\sour
                    -ce\USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\clock;.\so
                    -urce\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\cmd.lst) TABS(2) OBJECT(.\outp
                    -ut\cmd.obj)

line level    source

   1          #include "cmd.h"
   2          #include "uart.h"
   3          #include "clock.h"
   4          #include <ctype.h>
   5          #include <string.h>
   6          
   7          /* Display prompt string */
   8          code char *PROMPT =
   9             "\n#> "
  10             ;
  11          /* Copyright string */
  12          code char *COPYRIGHT =
  13           "\n"
  14           "SARI51 Copyright 2012-22"
  15             ;
  16          /* Local constants */
  17          code char *intro=
  18           "\n"
  19          // " SARI51 Command Line Interface"
  20           "SARI51 CLI"
  21             ;
  22          code char *help = 
  23           "\n"
  24               "+==== Command ===+= Function =============+\n"
  25          //   "|INFO            | Display system info    |\n"
  26          //   "|HELP or ?       | Display this help      |\n"
  27          //   "|----------------+------------------------|\n"
  28          //   "|LED [n] [op]    | Turn on/off led        |\n"
  29               "|TRAC            | Tracing Adjust Radio   |\n"
  30          //   "|XRAM [addr] <va>| Read/Write XRAM        |\n"
  31          //   "|REG  [reg] <va> | Read/Write SPI Register|\n"
  32               "|FREQ <va>       | Get/Set Frequency      |\n"
  33               "|COLC <va>       | Get/Set COLC           |\n"
  34               "|DIFF <va>       | Get/Set DesiredOffset  |\n"
  35               "|RATE <va>       | Get/Set RF Baudrate    |\n"
  36               "|TXPW <va>       | Get/Set RF TX Power    |\n"
  37          //   "|SEND            | Wireless Send Frame    |\n"
  38          //   "|RECV            | Wireless Receive Frame |\n"
  39               "|LOAD            | Read Flash Settings    |\n"
  40               "|SAVE            | Save to Flash          |\n"
  41               "+----------------+------------------------+"
  42             ;
  43          
  44          static void cmd_help (char *par) 
  45          {
  46   1        par=par;
  47   1        printf(help);
  48   1        return;
  49   1      }
  50          
  51          code CMD_TYPE cmd[] = {
  52          //  "RECV", cmd_recv,
C51 COMPILER V9.54   CMD                                                                   03/08/2017 15:17:00 PAGE 2   

  53          //  "XRAM", cmd_xram,
  54          //  "REG",  cmd_reg,
  55            //"FREQ", cmd_freq,
  56            //"COLC", cmd_colc,
  57            //"DIFF", cmd_diff,
  58            ////"RATE", cmd_rate,
  59            //"TXPW", cmd_txpower,
  60          //  "SEND", cmd_send,
  61            //"LED",  cmd_led,
  62            //"TRAC", cmd_trace,
  63            //"LOAD", cmd_load,
  64            //"SAVE", cmd_save,
  65            //"INFO", cmd_info,
  66            "HELP", cmd_help,
  67            //"?",    cmd_help
  68            };
  69            
  70          #define CMD_COUNT   (sizeof (cmd) / sizeof (cmd[0]))
  71            
  72          xdata char in_line[CMD_BUF_LEN_MAX] = { 0 };
  73          
  74          int getline(char * lp, uint32_t n)
  75          {
  76   1          uint32_t cnt = 0;
  77   1          char c;
  78   1        
  79   1          if( avalible() > 0 )
  80   1          {
  81   2            do 
  82   2            {
  83   3                //clock_delay(CMD_GET_LINE_DELAY);
  84   3                c = getchar();
  85   3                switch(c) 
  86   3                {
  87   4                     case CMD_FLAG_CNTL_Q:   /* ignore Control S/Q             */
  88   4                     case CMD_FLAG_CNTL_S:
  89   4                     break;
  90   4                    
  91   4                     case CMD_FLAG_BACKSPACE:
  92   4                     case CMD_FLAG_DEL:
  93   4                        if (cnt == 0) {
  94   5                           break;
  95   5                        }
  96   4                        cnt--;                         /* decrement count                */
  97   4                        lp--;                          /* and line pointer               */
  98   4                        putchar (0x08);                /* echo backspace                 */
  99   4                        putchar (' ');
 100   4                        putchar (0x08);
 101   4                        break;
 102   4                     case CMD_FLAG_ESC:
 103   4                        *lp = 0;                       /* ESC - stop editing line        */
 104   4                        return (FALSE);
 105   4                     case CMD_FLAG_CR:                          /* CR - done, stop editing line   */
 106   4                        *lp = c;
 107   4                        lp++;                          /* increment line pointer         */
 108   4                        cnt++;                         /* and count                      */
 109   4                        c = CMD_FLAG_LF;
 110   4                     default:
 111   4                        *lp = c;
 112   4                        //putchar (c); 
 113   4                        putchar (*lp);             /* echo and store character       */
 114   4                        
C51 COMPILER V9.54   CMD                                                                   03/08/2017 15:17:00 PAGE 3   

 115   4                        lp++;                          /* increment line pointer         */
 116   4                        cnt++;                         /* and count                      */
 117   4                        break;
 118   4              }
 119   3           } while (cnt < n - 2  &&  c != CMD_FLAG_LF);     /* check limit and CR             */
 120   2         }
 121   1          
 122   1         *lp = 0;    
 123   1                                  /* mark end of string             */
 124   1         return (TRUE);
 125   1      }
 126          
 127          int strtoul(char *s)
 128          {
 129   1        int ret;
 130   1        int radix = 10;
 131   1        int negative = 0;
 132   1        int i;
 133   1        ret = 0;
 134   1        if(*s == '-') 
 135   1        {
 136   2          negative = 1;
 137   2          s++;
 138   2        }
 139   1        else if(*s == '0')
 140   1        {
 141   2          s++;
 142   2          if(*s == 'x')
 143   2          {
 144   3            s++;
 145   3            radix = 0x10;
 146   3          }
 147   2        }
 148   1        while (*s) {
 149   2          if (*s >= '0' && *s <= '9')
 150   2            i = *s - '0';
 151   2          else if (*s >= 'a' && *s <= 'f')
 152   2            i = *s - 'a' + 0xa;
 153   2          else if (*s >= 'A' && *s <= 'F')
 154   2            i = *s - 'A' + 0xa;
 155   2          else
 156   2            break;
 157   2          if(i >= radix) break;
 158   2          ret = (ret * radix) + i;
 159   2          s++;
 160   2        }
 161   1        return negative?(-ret):ret;
 162   1      }
 163          
 164          char *getentry(char *cp, char **ppNext)
 165          {
 166   1        char *sp, lfn = 0, sep_ch = ' ';
 167   1         if (cp == NULL) {                          /* skip NULL pointers          */
 168   2            *ppNext = cp;
 169   2            return (cp);
 170   2         }
 171   1         for ( ; *cp == ' ' || *cp == '\"'; cp++) { /* skip blanks and starting  " */
 172   2            if (*cp == '\"') { sep_ch = '\"'; lfn = 1; }
 173   2            *cp = 0;
 174   2         }
 175   1         for (sp = cp; *sp != CMD_FLAG_CR && *sp != CMD_FLAG_LF; sp++) {
 176   2            if ( lfn && *sp == '\"') break;
C51 COMPILER V9.54   CMD                                                                   03/08/2017 15:17:00 PAGE 4   

 177   2            if (!lfn && *sp == ' ' ) break;
 178   2         }
 179   1         for ( ; *sp == sep_ch || *sp == CMD_FLAG_CR || *sp == CMD_FLAG_LF; sp++) {
 180   2            *sp = 0;
 181   2            if ( lfn && *sp == sep_ch) { sp ++; break; }
 182   2         }
 183   1         *ppNext = (*sp) ? sp : NULL;                /* next entry                  */
 184   1         return (cp);
 185   1      }
 186          
 187          int cmd_master(void)
 188          {
 189   1         int ret = TRUE;
 190   1         char *sp=NULL,*cp=NULL,*next=NULL;
 191   1         int8_t i;
 192   1         unsigned char u = 0;
 193   1         //printf (intro);                            /* display example info        */
 194   1         //printf (help);
 195   1         //cmd[0].func(NULL); //?????recv??
 196   1            //printf (PROMPT);                     /* display prompt              */
 197   1            /* get command line input      */
 198   1          ret = getline (in_line, CMD_BUF_LEN_MAX);
 199   1          if( FALSE == ret ) 
 200   1          {
 201   2            printf("get line failed\n");
 202   2          }
 203   1          else
 204   1          {
 205   2            printf("getline %s\n", in_line);
 206   2            sp = getentry (&in_line[0], &next);
 207   2            if (*sp != 0) 
 208   2            {
 209   3               for (cp = sp; *cp && (*cp != ' '); cp++) {
 210   4               *cp = toupper (*cp);                 /* command to upper-case       */
 211   4              }
 212   3               
 213   3              for (i = 0; i < CMD_COUNT; i++) 
 214   3              {
 215   4                 if (0 == strcmp (sp, (const char *)&cmd[i].name)) 
 216   4                 {
 217   5                    cmd[i].func (next);                  /* execute command function    */
 218   5                    break;
 219   5                 }
 220   4                 
 221   4              }
 222   3              
 223   3              if (i == CMD_COUNT) {
 224   4                ret = FALSE;
 225   4                printf ("\ncmd error\n");
 226   4              }
 227   3            }
 228   2          }
 229   1          
 230   1          return ret;
 231   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2114    ----
   CONSTANT SIZE    =    548    ----
   XDATA SIZE       =     82    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.54   CMD                                                                   03/08/2017 15:17:00 PAGE 5   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
