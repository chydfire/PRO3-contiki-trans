C51 COMPILER V9.54   MAIN                                                                  03/07/2017 19:19:56 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\output\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\main.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\source\
                    -USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\clock;.\sourc
                    -e\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\output
                    -\main.obj)

line level    source

   1          /************************************************/
   2          //MCU: SN8F5708
   3          //PRJ: A7139
   4          //DATE:2016-5-27
   5          /************************************************/
   6          
   7          #include <SN8F5708.h>
   8          #include <intrins.h> //for _nop_
   9          #include "A7139.h"
  10          #include "clock.h"
  11          #include "uart.h"
  12          #include "led.h"
  13          #include "rtimer.h"
  14          #include "cmd.h"
  15          
  16          rtimer_clock_t rt_now = 0;
  17          struct rtimer rt;
  18          
  19          
  20          void
  21          rt_callback(void)
  22          {
  23   1        printf("rtimer call back\n");
  24   1        toggle_led_red;
  25   1        rt_now = RTIMER_NOW();
  26   1        rtimer_set(&rt, rt_now + 65530UL, 1,(void *) rt_callback, &rt_now);
  27   1      }
  28          int main(void)
  29          {
  30   1        
  31   1        WDTR = 0x5A;            // clear watchdog if watchdog enable
  32   1        led_init();             //led initial
  33   1        clock_init();
  34   1        uart_init();            //uart initial 57600
  35   1        rtimer_init();
  36   1        printf("test printf\n");
  37   1        rt_now = RTIMER_NOW();
  38   1        rtimer_set(&rt, rt_now + RTIMER_ARCH_SECOND*1UL, 1,(void *) rt_callback, &rt_now);
  39   1        cmdline();
  40   1        
  41   1        return 0;
  42   1      }
  43          
  44          
  45          #if 0
              
              #include <SN8F5708.h>
              #include <intrins.h> //for _nop_
              #include "A7139.h"
              #include "timer.h"
              #include "uart.h"
              #include "led.h"
C51 COMPILER V9.54   MAIN                                                                  03/07/2017 19:19:56 PAGE 2   

              
              void a7139_tx_packet(unsigned char *s,unsigned char n);
              
              #define RF_STATE_A7139_RX   1
              #define RF_STATE_A7139_TX   2
              #define RF_STATE_A7139_IDLE 3
              u8 idata rf_state_a7139 = 1;
              u8 idata a7139_irq_status = 0;
              
              u16 idata crc_check_code = 0;
              u8 idata crc_check_code_l = 0;
              u8 idata crc_check_code_h = 0;
              
              extern u8 idata timer0_flag;
              extern u8 idata timer1_flag;
              u8 idata bufSend[]= {"A7139"};
              u8 idata bufRecv[7]={0};
              
              u8 idata string_test[] = {"hellow !"};
              u8 idata i = 0;
              
              extern u8 idata UartRxFlag;
              extern u8 idata RxBuf[7];
              u8 xdata a7139_tx[7]={0};
              
              //定义二维数组，存放向各节点要发送的数据，注意第3字节为节点地址，节点接收到数据后需比对节点地址
               u8 xdata slave_cmd[10][7] = {{0xaa,0xbb,0x01,0x00,0x00,0x3c,0x49},
                                           {0xaa,0xbb,0x02,0x00,0x00,0x3c,0xb9},
                                           {0xaa,0xbb,0x03,0x00,0x00,0xfc,0xe8},
                                           {0xaa,0xbb,0x04,0x00,0x00,0x3d,0x59},
                                           {0xaa,0xbb,0x05,0x00,0x00,0xfd,0x08},
                                           {0xaa,0xbb,0x06,0x00,0x00,0xfd,0xf8},
                                           {0xaa,0xbb,0x07,0x00,0x00,0x3d,0xa9},
                                           {0xaa,0xbb,0x08,0x00,0x00,0x3e,0x99},
                                           {0xaa,0xbb,0x09,0x00,0x00,0xfe,0xc8},
                                           {0xaa,0xbb,0x0a,0x00,0x00,0xfe,0x38}};
              
              void main(void)
              {
                WDTR = 0x5A;            // clear watchdog if watchdog enable
                
                //led initial
                led_init();
                
                //uart initial 57600
                uart_init();
                
                //a7139 initial
                delay_ms(10);
                init_spi_a7139();
                delay_ms(10);
                if(A7139_Init(475.001f) != 0)
                {
                  close_led_red; //a7139 initial fail! close led 
                }
                else
                {   
                  open_led_red; //a7139 initial ok!  open led
                }
                A7139_StrobeCmd(CMD_RX); //enter RX 
                delay_ms(10);//For some perform faster MCU, need time to wait at least more than 10 millisecond
              //  rf_state_a7139 = RF_STATE_A7139_RX;
C51 COMPILER V9.54   MAIN                                                                  03/07/2017 19:19:56 PAGE 3   

                rf_state_a7139 = RF_STATE_A7139_IDLE;
                
                //timer initial
                timer_init();
                
                 while(1)
                 {
                    //send a tx packet per 100ms
                   if(timer1_flag == 1)
                   {
                     timer1_flag = 0;
                       
                     if(i < 10)
                     {
                        a7139_tx_packet(slave_cmd[i],7);
                        i++;
                     }
                     else
                     {
                        i = 0;
                     }
                   }
                   
                   //A7139 interrupt
                   if(a7139_irq_status == 1)
                   {
                    switch(rf_state_a7139)
                    {
                      case RF_STATE_A7139_IDLE:
                        A7139_ReadFIFO(bufRecv,sizeof(bufSend));
                        A7139_StrobeCmd(CMD_RX);
                        rf_state_a7139 = RF_STATE_A7139_RX;
                        break;
                      case RF_STATE_A7139_RX:
                        A7139_ReadFIFO(bufRecv,sizeof(bufRecv));
                        A7139_StrobeCmd(CMD_RX);                
                      
                        crc_check_code = Get_CRC_Check_Code(bufRecv,sizeof(bufRecv)-2);
                        crc_check_code_l = 0xff & crc_check_code;
                        crc_check_code_h = 0xff & (crc_check_code>>8);
                        if((crc_check_code_h == bufRecv[5])&&(crc_check_code_l == bufRecv[6]))  //CRC 校验,高字节在前
                        {
                          if(bufRecv[2] == 0x0a)//节点地址
                          {
                            uart_send_string(bufRecv,sizeof(bufRecv));//debug 
                            toggle_led_red;
                          }
                        }
                        break;
                      case RF_STATE_A7139_TX:
                        //tx completed
                        toggle_led_blue;//debug     
                        A7139_StrobeCmd(CMD_RX); //enter RX 
                        delay_ms(10);//For some perform faster MCU, need time to wait at least more than 10 millisecond
                        rf_state_a7139 = RF_STATE_A7139_RX;       
                        break;
                    }
              
                    a7139_irq_status = 0;
                   }
                   
                   //uart received a packet
C51 COMPILER V9.54   MAIN                                                                  03/07/2017 19:19:56 PAGE 4   

                   if(UartRxFlag == 1)
                   {
              //       crc_check_code = Get_CRC_Check_Code(RxBuf,5);
              //       crc_check_code_l = 0xff & crc_check_code;
              //       crc_check_code_h = 0xff & (crc_check_code>>8);
              //       uart_send_byte(crc_check_code_h);  //debug
              //       uart_send_byte(crc_check_code_l);
              //       if((RxBuf[5] == crc_check_code_h)&&(RxBuf[6] == crc_check_code_l))  //CRC 校验,高字节在前
              //       {
              //          toggle_led_red;
              
              //          if(i < 10)
              //          {
              //            a7139_tx_packet(slave_cmd[i],7);
              //            i++;
              //          }
              //          else
              //          {
              //            i = 0;
              //          }
              //       }
              //       
              //       UartRxFlag = 0;
                   }
                 }
              }
              
              
              //INT1 interrupt function
              void INT1Interrupt(void) interrupt ISRInt1 //
              { //IE0 clear by hardware
                a7139_irq_status = 1; 
              }
              
              //a7139 transmit a packet
              void a7139_tx_packet(unsigned char *s,unsigned char n)
              {
                  A7139_StrobeCmd(CMD_STBY);
                  delay_ms(10);
                  //send a tx packet
              //    A7139_WriteFIFO(s,7);
                  A7139_WriteFIFO(s,n);
                  A7139_StrobeCmd(CMD_TX);
                  delay_ms(10);//For some perform faster MCU, need time to wait at least more than 10 millisecond
                  rf_state_a7139 =  RF_STATE_A7139_TX;
              }
              
              #endif
 225            
 226          
 227          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    247    ----
   CONSTANT SIZE    =     31    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.54   MAIN                                                                  03/07/2017 19:19:56 PAGE 5   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
