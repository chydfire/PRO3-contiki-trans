C51 COMPILER V9.54   A7139_COMM                                                            03/08/2017 15:17:00 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE A7139_COMM
OBJECT MODULE PLACED IN .\output\A7139_comm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\A7139\A7139_comm.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCD
                    -IR(.\source\USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\c
                    -lock;.\source\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\A7139_comm.lst) TABS(
                    -2) OBJECT(.\output\A7139_comm.obj)

line level    source

   1          #include "A7139_comm.h"
   2          #include "A7139.h"
   3          #include "SN8F5708.h"
   4          #include "uart.h"
   5          #include "led.h"
   6          
   7          uint8_t idata rf_state_a7139 = RF_STATE_A7139_IDLE;
   8          uint8_t idata a7139_irq_status = 0;
   9          
  10          uint16_t idata crc_check_code = 0;
  11          uint8_t idata crc_check_code_l = 0;
  12          uint8_t idata crc_check_code_h = 0;
  13          
  14          extern uint8_t idata timer0_flag;
  15          extern uint8_t idata timer1_flag;
  16          uint8_t idata bufSend[]=  {"A7139"};
  17          uint8_t idata bufRecv[RF_RECV_BUF_LEN_MAX]={0};
  18          
  19          uint8_t idata string_test[] = {"hellow !"};
  20          uint8_t idata i = 0;
  21          
  22          extern uint8_t idata UartRxFlag;
  23          extern uint8_t idata RxBuf[RF_RECV_BUF_LEN_MAX];
  24          uint8_t xdata a7139_tx[RF_RECV_BUF_LEN_MAX]={0};
  25          
  26          extern uint8_t xdata per_second_flag;
  27          
  28          //定义二维数组，存放向各节点要发送的数据，注意第3字节为节点地址，节点接收到数据后需比对节点地址
  29           uint8_t xdata slave_cmd[10][RF_RECV_BUF_LEN_MAX] = {{0xaa,0xbb,0x0a,0x00,0x00,0xfe,0x38},
  30                                       {0xaa,0xbb,0x02,0x00,0x00,0x3c,0xb9},
  31                                       {0xaa,0xbb,0x03,0x00,0x00,0xfc,0xe8},
  32                                       {0xaa,0xbb,0x04,0x00,0x00,0x3d,0x59},
  33                                       {0xaa,0xbb,0x05,0x00,0x00,0xfd,0x08},
  34                                       {0xaa,0xbb,0x06,0x00,0x00,0xfd,0xf8},
  35                                       {0xaa,0xbb,0x07,0x00,0x00,0x3d,0xa9},
  36                                       {0xaa,0xbb,0x08,0x00,0x00,0x3e,0x99},
  37                                       {0xaa,0xbb,0x09,0x00,0x00,0xfe,0xc8},
  38                                       {0xaa,0xbb,0x0a,0x00,0x00,0xfe,0x38}};
  39           
  40                                       
  41          //INT1 interrupt function
  42          void INT1Interrupt(void) interrupt ISRInt1 //
  43          { //IE0 clear by hardware
  44   1        a7139_irq_status = 1; 
  45   1      }
  46          
  47          //a7139 transmit a packet
  48          void a7139_tx_packet(uint8_t *s,uint8_t n)
  49          {
  50   1          A7139_StrobeCmd(CMD_STBY);
  51   1          delay_ms(10);
  52   1          //send a tx packet
C51 COMPILER V9.54   A7139_COMM                                                            03/08/2017 15:17:00 PAGE 2   

  53   1      //    A7139_WriteFIFO(s,7);
  54   1          A7139_WriteFIFO(s,n);
  55   1          A7139_StrobeCmd(CMD_TX);
  56   1          delay_ms(10);//For some perform faster MCU, need time to wait at least more than 10 millisecond
  57   1          rf_state_a7139 =  RF_STATE_A7139_TX;
  58   1      }
  59          
  60          int a7139_master()
  61          {
  62   1          int ret = TRUE;
  63   1          int i = 0;
  64   1        
  65   1          //send a tx packet per 100ms
  66   1           if(per_second_flag == 1)
  67   1           {
  68   2             per_second_flag = 0;
  69   2               
  70   2             if(i < 10)
  71   2             {
  72   3                a7139_tx_packet(slave_cmd[i],RF_RECV_BUF_LEN_MAX);
  73   3                i++;
  74   3             }
  75   2             else
  76   2             {
  77   3                i = 0;
  78   3             }
  79   2           }
  80   1           //A7139 interrupt
  81   1           if(a7139_irq_status == 1)
  82   1           {
  83   2            switch(rf_state_a7139)
  84   2            {
  85   3              case RF_STATE_A7139_IDLE:
  86   3                A7139_ReadFIFO(bufRecv,sizeof(bufSend));
  87   3                A7139_StrobeCmd(CMD_RX);
  88   3                rf_state_a7139 = RF_STATE_A7139_RX;
  89   3                break;
  90   3              case RF_STATE_A7139_RX:
  91   3                A7139_ReadFIFO(bufRecv,sizeof(bufRecv));
  92   3                A7139_StrobeCmd(CMD_RX);                
  93   3              
  94   3                crc_check_code = Get_CRC_Check_Code(bufRecv,sizeof(bufRecv)-2);
  95   3                crc_check_code_l = 0xff & crc_check_code;
  96   3                crc_check_code_h = 0xff & (crc_check_code>>8);
  97   3                if((crc_check_code_h == bufRecv[5])&&(crc_check_code_l == bufRecv[6]))  //CRC 校验,高字节在前
  98   3                {
  99   4                  if(bufRecv[2] == 0x0a)//节点地址
 100   4                  {
 101   5                    uart_send_string(bufRecv,sizeof(bufRecv));//debug 
 102   5                    toggle_led_red;
 103   5                  }
 104   4                }
 105   3                break;
 106   3              case RF_STATE_A7139_TX:
 107   3                //tx completed
 108   3                toggle_led_blue;//debug     
 109   3                A7139_StrobeCmd(CMD_RX); //enter RX 
 110   3                delay_ms(10);//For some perform faster MCU, need time to wait at least more than 10 millisecond
 111   3                rf_state_a7139 = RF_STATE_A7139_RX;       
 112   3                break;
 113   3            }
 114   2      
C51 COMPILER V9.54   A7139_COMM                                                            03/08/2017 15:17:00 PAGE 3   

 115   2            a7139_irq_status = 0;
 116   2           }
 117   1           //uart received a packet
 118   1      //     if(UartRxFlag == 1)
 119   1      //     {
 120   1      //       crc_check_code = Get_CRC_Check_Code(RxBuf,5);
 121   1      //       crc_check_code_l = 0xff & crc_check_code;
 122   1      //       crc_check_code_h = 0xff & (crc_check_code>>8);
 123   1      //       uart_send_byte(crc_check_code_h);  //debug
 124   1      //       uart_send_byte(crc_check_code_l);
 125   1      //       if((RxBuf[5] == crc_check_code_h)&&(RxBuf[6] == crc_check_code_l))  //CRC 校验,高字节在前
 126   1      //       {
 127   1      //          toggle_led_red;
 128   1      
 129   1      //          if(i < 10)
 130   1      //          {
 131   1      //            a7139_tx_packet(slave_cmd[i],7);
 132   1      //            i++;
 133   1      //          }
 134   1      //          else
 135   1      //          {
 136   1      //            i = 0;
 137   1      //          }
 138   1      //       }
 139   1      //       
 140   1      //       UartRxFlag = 0;
 141   1      //     }
 142   1         return ret;
 143   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    390    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     85    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     29    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
