C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE A7139
OBJECT MODULE PLACED IN .\output\A7139.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\A7139\A7139.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\
                    -source\USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\clock;
                    -.\source\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\A7139.lst) TABS(2) OBJECT(
                    -.\output\A7139.obj)

line level    source

   1          #include "A7139.h"
   2          #include "clock.h"
   3          
   4          
   5          #define open_led1   P26 = 0
   6          #define close_led1  P26 = 1
   7          #define toggle_led1 P26 = ~P26
   8          #define open_led2   P27 = 0
   9          #define close_led2  P27 = 1
  10          #define toggle_led2 P27 = ~P27
  11          
  12          void A7139_WriteReg(Uint8 regAddr, Uint16 regVal)
  13          {
  14   1          SCS_OUT(LOW);
  15   1          regAddr |= CMD_Reg_W;
  16   1          SPIx_WriteByte(regAddr);
  17   1          clock_delay_us(1);
  18   1          SPIx_WriteWord(regVal);
  19   1          SCS_OUT(HIGH);
  20   1      }
  21          
  22          Uint16 A7139_ReadReg(Uint8 regAddr)
  23          {
  24   1      //    Uint16 regVal;
  25   1          Uint16 regVal = 0;
  26   1          SCS_OUT(LOW);
  27   1          regAddr |= CMD_Reg_R;
  28   1          SPIx_WriteByte(regAddr);
  29   1          clock_delay_us(1);
  30   1          regVal=SPIx_ReadWord();
  31   1          SCS_OUT(HIGH);
  32   1          return regVal;
  33   1      }
  34          
  35          void A7139_WritePageA(Uint8 address, Uint16 dataWord)
  36          {
  37   1      //    Uint16 tmp;
  38   1          Uint16 idata tmp;
  39   1          tmp = address;
  40   1          tmp = ((tmp << 12) | A7139Config[CRYSTAL_REG]);
  41   1          A7139_WriteReg(CRYSTAL_REG, tmp);
  42   1          A7139_WriteReg(PAGEA_REG, dataWord);
  43   1      }
  44          
  45          void A7139_WritePageB(Uint8 address, Uint16 dataWord)
  46          {
  47   1      //    Uint16 tmp;
  48   1          Uint16 idata tmp;
  49   1          tmp = address;
  50   1          tmp = ((tmp << 7) | A7139Config[CRYSTAL_REG]);
  51   1          A7139_WriteReg(CRYSTAL_REG, tmp);
  52   1          A7139_WriteReg(PAGEB_REG, dataWord);
C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 2   

  53   1      }
  54          
  55          Uint16 A7139_ReadPageA(Uint8 address)
  56          {
  57   1      //    Uint16 tmp;
  58   1          Uint16 idata tmp;
  59   1          tmp = address;
  60   1          tmp = ((tmp << 12) | A7139Config[CRYSTAL_REG]);
  61   1          A7139_WriteReg(CRYSTAL_REG, tmp);
  62   1          tmp = A7139_ReadReg(PAGEA_REG);
  63   1          return tmp;
  64   1      }
  65          
  66          void A7139_Config(void)
  67          {
  68   1      //  Uint8 i;
  69   1          Uint8 idata i;
  70   1        for(i=0; i<8; i++)
  71   1              A7139_WriteReg(i, A7139Config[i]);
  72   1        for(i=10; i<16; i++)
  73   1              A7139_WriteReg(i, A7139Config[i]);
  74   1           for(i=0; i<16; i++)
  75   1              A7139_WritePageA(i, A7139Config_PageA[i]);
  76   1        for(i=0; i<5; i++)
  77   1              A7139_WritePageB(i, A7139Config_PageB[i]);
  78   1      }
  79          
  80          Uint8 A7139_Cal(void)
  81          {
  82   1      //  Uint8  fbcf;  //IF Filter
  83   1      //  Uint8  vbcf;  //VCO Current
  84   1      //  Uint8  vccf;  //VCO Band
  85   1      //  Uint16 tmp;
  86   1        Uint8  idata fbcf;  //IF Filter
  87   1        Uint8  idata vbcf;  //VCO Current
  88   1        Uint8  idata vccf;  //VCO Band
  89   1        Uint16 idata tmp;
  90   1        
  91   1        tmp = A7139_ReadReg(TX2_PAGEB);      //read chip id 0x1221
  92   1      
  93   1         /******************************************************************************************************/
  94   1      //   A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0002);      //IF Filter Calibration     
  95   1      //     do{
  96   1      //    tmp = A7139_ReadReg(MODE_REG);
  97   1      //    //wxq add
  98   1      //    delay_ms(100);
  99   1      //     }while(tmp & 0x0002);
 100   1      
 101   1      //     //for check(IF Filter)  
 102   1      //     tmp = A7139_ReadReg(CALIBRATION_REG); 
 103   1      //     fbcf = (tmp>>4) & 0x01;
 104   1      //     if(fbcf)
 105   1      //     {
 106   1      //       //wxq_test  1. IF filter fail
 107   1      //       close_led1;   //close led    
 108   1      //     }
 109   1      //     else
 110   1      //     {
 111   1      //       open_led1;   //open led
 112   1      //     }
 113   1      ////   return 0;//test
 114   1      //   /****************************************************************************************************/
C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 3   

 115   1      
 116   1      //  A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0004);       //VCO Bank Calibration       
 117   1      //  do{
 118   1      //    tmp = A7139_ReadReg(MODE_REG);
 119   1      //  }while(tmp & 0x0004);
 120   1      
 121   1      //   //for check(VCO Bank)
 122   1      //  tmp = A7139_ReadReg(CALIBRATION_REG);
 123   1      //  vbcf = (tmp >>8) & 0x01;
 124   1      //  if(vbcf)
 125   1      //  {
 126   1      //    //wxq_test  2. VCO Bank fail
 127   1      //    close_led1;   //close led 
 128   1      //  }
 129   1      //  else
 130   1      //   {
 131   1      //     open_led1;   //open led 
 132   1      //   }
 133   1      ////   return 0;//test
 134   1      ///*******************************************************************************************************
             -**********************************/
 135   1      //  A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x2800);     //VCO Current Calibration    
 136   1      //  
 137   1      //     do{
 138   1      //    tmp = A7139_ReadReg(MODE_REG);
 139   1      //    //wxq add
 140   1      //    delay_ms(100);
 141   1      //     }while(tmp & 0x0800);
 142   1      
 143   1      //  //for check(VCO Current)
 144   1      //     tmp = A7139_ReadPageA(VCB_PAGEA);
 145   1      //    vccf = (tmp>>4) & 0x01;
 146   1      //    if(vccf)
 147   1      //    {
 148   1      //      //wxq_test  3. VCO Current fail
 149   1      //      close_led1;   //close led 
 150   1      //    }
 151   1      //    else
 152   1      //    {
 153   1      //      open_led1;   //open led 
 154   1      //    }
 155   1      //    return 0;//test
 156   1      /*********************************************************************************************************
             -********************************/
 157   1          
 158   1          
 159   1          //IF calibration procedure @STB state
 160   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0802);     //IF Filter & VCO Current Calibration
 161   1           do{
 162   2          tmp = A7139_ReadReg(MODE_REG);
 163   2           }while(tmp & 0x0802);
 164   1          //for check(IF Filter)
 165   1           tmp = A7139_ReadReg(CALIBRATION_REG);
 166   1           //fb = tmp & 0x0F;
 167   1           //fcd = (tmp>>11) & 0x1F;
 168   1           fbcf = (tmp>>4) & 0x01;
 169   1           if(fbcf)
 170   1           {
 171   2          return ERR_CAL;
 172   2           }
 173   1        //for check(VCO Current)
 174   1           tmp = A7139_ReadPageA(VCB_PAGEA);
C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 4   

 175   1        //vcb = tmp & 0x0F;
 176   1        vccf = (tmp>>4) & 0x01;
 177   1        if(vccf)
 178   1        {
 179   2              return ERR_CAL;
 180   2           }
 181   1          //RSSI Calibration procedure @STB state
 182   1        A7139_WriteReg(ADC_REG, 0x4C00);                  //set ADC average=64
 183   1           A7139_WritePageA(WOR2_PAGEA, 0xF800);                //set RSSC_D=40us and RS_DLY=80us
 184   1        A7139_WritePageA(TX1_PAGEA, A7139Config_PageA[TX1_PAGEA] | 0xE000); //set RC_DLY=1.5ms
 185   1           A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x1000);      //RSSI Calibration
 186   1           do{
 187   2          tmp = A7139_ReadReg(MODE_REG);
 188   2           }while(tmp & 0x1000);
 189   1        A7139_WriteReg(ADC_REG, A7139Config[ADC_REG]);
 190   1           A7139_WritePageA(WOR2_PAGEA, A7139Config_PageA[WOR2_PAGEA]);
 191   1        A7139_WritePageA(TX1_PAGEA, A7139Config_PageA[TX1_PAGEA]);
 192   1          //VCO calibration procedure @STB state
 193   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0004);   //VCO Band Calibration
 194   1        do{
 195   2          tmp = A7139_ReadReg(MODE_REG);
 196   2        }while(tmp & 0x0004);
 197   1          //for check(VCO Band)
 198   1        tmp = A7139_ReadReg(CALIBRATION_REG);
 199   1        //vb = (tmp >>5) & 0x07;
 200   1        vbcf = (tmp >>8) & 0x01;
 201   1        if(vbcf)
 202   1        {
 203   2          return ERR_CAL;
 204   2        }
 205   1        return 0;
 206   1      }
 207          
 208          void A7139_SetFreq(float rfFreq)
 209          {
 210   1      //   float  divFreq = rfFreq / 12.800f;  
 211   1      //   Uint8  intFreq = (Uint8)(divFreq); //integer part
 212   1      //   float  fltFreq = divFreq - intFreq * 1.000f; //fraction part
 213   1      //   Uint16 fpFreg  = (Uint16)(fltFreq * 65536);  //FP register val
 214   1      //   Uint16 orgVal;
 215   1         float  idata divFreq = rfFreq / 12.800f;  
 216   1         Uint8  idata intFreq = (Uint8)(divFreq); //integer part
 217   1         float  idata fltFreq = divFreq - intFreq * 1.000f; //fraction part
 218   1         Uint16 idata fpFreg  = (Uint16)(fltFreq * 65536);  //FP register val
 219   1         Uint16 idata orgVal;
 220   1         A7139_StrobeCmd(CMD_STBY); //enter stand-by mode
 221   1             //AFC[15:15] = 0
 222   1         orgVal = A7139Config[PLL3_REG] & 0x7FFF;
 223   1         A7139_WriteReg(PLL3_REG,orgVal);
 224   1            //RFC[15:12] = 0000
 225   1         orgVal = A7139Config[PLL6_REG] & 0x0FFF;
 226   1         A7139_WriteReg(PLL6_REG,orgVal);
 227   1          //MD1[12:12]=0,1
 228   1         if(rfFreq < 860) //433-510
 229   1          orgVal = A7139Config[PLL4_REG] & 0xEFFF;
 230   1         else  //868-915
 231   1          orgVal = A7139Config[PLL4_REG] | 0x1000;
 232   1         A7139_WriteReg(PLL4_REG,orgVal);
 233   1            //IP[8:0] = intg
 234   1         orgVal = A7139Config[PLL1_REG] & 0xFF00;
 235   1         A7139_WriteReg(PLL1_REG,orgVal|intFreq);
 236   1            //FP[15:0] =  fpFreg
C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 5   

 237   1         A7139_WriteReg(PLL2_REG,fpFreg); 
 238   1            //FPA[15:0] = 0x0000
 239   1         A7139_WritePageB(IF2_PAGEB,0x0000);  
 240   1      }
 241          
 242          Uint8 A7139_RCOSC_Cal(void)
 243          {
 244   1      //    Uint8  retry = 0xFF;
 245   1      //    Uint16 calbrtVal,t_retry=0xFFFF;
 246   1          Uint8  idata retry = 0xFF;
 247   1          Uint16 idata calbrtVal,t_retry=0xFFFF;
 248   1              //RCOSC_E[4:4] = 1,enable internal RC Oscillator
 249   1          A7139_WritePageA(WOR2_PAGEA, A7139Config_PageA[WOR2_PAGEA] | 0x0010);
 250   1          do{
 251   2                //ENCAL[0:0] = 1,then start RC OSC Calbrt
 252   2            A7139_WritePageA(WCAL_PAGEA, A7139Config_PageA[WCAL_PAGEA] | 0x0001);
 253   2            do{
 254   3                calbrtVal = A7139_ReadPageA(WCAL_PAGEA) & 0x0001;
 255   3            }while(calbrtVal && t_retry--);
 256   2                //read NUMLH[9:1]
 257   2            calbrtVal = (A7139_ReadPageA(WCAL_PAGEA) & 0x03FF) >> 1;
 258   2            if(calbrtVal>186 && calbrtVal<198)
 259   2               return OK_RCOSC_CAL;
 260   2          }while(retry--);
 261   1          return ERR_RCOSC_CAL;
 262   1      }
 263          
 264          void A7139_StrobeCmd(Uint8 cmd)
 265          {
 266   1          SCS_OUT(LOW);
 267   1          SPIx_WriteByte(cmd);
 268   1          SCS_OUT(HIGH);
 269   1      }
 270          
 271          Uint8 A7139_Init(float rfFreq)
 272          {
 273   1      //  IO_Init();
 274   1        SCS_OUT(HIGH);
 275   1        SCK_OUT(LOW);
 276   1           A7139_StrobeCmd(CMD_RF_RST);   //reset A7139 chip
 277   1      //  Delay_ms(10);
 278   1        clock_delay_ms(10);
 279   1        A7139_Config();     //config A7139 chip
 280   1        delay_ms(10);       //for crystal stabilized
 281   1        A7139_SetCID(0x3475C58C);  //set CID code
 282   1        delay_ms(1);
 283   1        A7139_SetFreq(rfFreq);    //set Freq
 284   1        delay_ms(10);
 285   1        return A7139_Cal();     //IF and VCO calibration
 286   1      }
 287          
 288          Uint8 A7139_SetCID(Uint32 id)
 289          {
 290   1        SCS_OUT(LOW);
 291   1        SPIx_WriteByte(CMD_CID_W);
 292   1        SPIx_WriteByte((Uint8)(id>>24));
 293   1        SPIx_WriteByte((Uint8)(id>>16));
 294   1        SPIx_WriteByte((Uint8)(id>>8));
 295   1        SPIx_WriteByte((Uint8)id);
 296   1        SCS_OUT(HIGH);
 297   1        return 0;
 298   1      }
C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 6   

 299          
 300          Uint16 A7139_ReadPID(void)
 301          {
 302   1      //  Uint16 pid;
 303   1      //  Uint16 pagAddr = TX2_PAGEB << 7;
 304   1        Uint16 idata pid;
 305   1        Uint16 idata pagAddr = TX2_PAGEB << 7;
 306   1        pagAddr|=A7139Config[CRYSTAL_REG] & 0xF7CF;
 307   1        A7139_WriteReg(CRYSTAL_REG, pagAddr);
 308   1        pid = A7139_ReadReg(PAGEB_REG);
 309   1        return pid;
 310   1      }
 311          
 312          Uint8 A7139_SetDataRate(Uint8 datRate)
 313          {
 314   1          //enter stand by mode
 315   1        A7139_StrobeCmd(CMD_STBY);
 316   1        clock_delay_ms(20);
 317   1            //set xs[0:0] = 0 to disable XTAL
 318   1        A7139_WriteReg(CRYSTAL_REG,A7139Config[CRYSTAL_REG] & 0xFFFE );
 319   1        switch(datRate)
 320   1        {
 321   2          case 2:
 322   2          { 
 323   3                //CSC[2:0]=[001],Fcsck=3.2MHz
 324   3                //IFBW[3:2]=[01],100kHz
 325   3                //SDR[15:9]=0x18,DCK=2Kps,Fdev = 7.8125kHz
 326   3            A7139_WriteReg(SYSTEMCLOCK_REG,0x6621); 
 327   3            A7139_WriteReg(RX1_REG,0x18D4); 
 328   3            A7139_WritePageA(TX1_PAGEA,0xF505);
 329   3          }
 330   2          break;
 331   2          case 10:
 332   2          {
 333   3                //CSC[2:0]=[001],Fcsck=6.4MHz
 334   3                //IFBW[3:2]=[01],100kHz
 335   3                //SDR[15:9]=0x04,DCK=10Kps,Fdev = 37.5kHz
 336   3            A7139_WriteReg(SYSTEMCLOCK_REG,0x01221);          
 337   3            A7139_WriteReg(RX1_REG,0x18D4);
 338   3            A7139_WritePageA(TX1_PAGEA,0xF706);
 339   3          }
 340   2          break;
 341   2          case 50:
 342   2          {
 343   3                //CSC[2:0]=[011],Fcsck=3.2MHz
 344   3                //IFBW[3:2]=[00],50Kps 
 345   3                //SDR[15:9]=0x00,DCK=50kHz,Fdev = 18.75kHz
 346   3            A7139_WriteReg(SYSTEMCLOCK_REG,0x0023);
 347   3            A7139_WriteReg(RX1_REG,0x18D0);
 348   3            A7139_WritePageA(TX1_PAGEA,0xF606);
 349   3          }
 350   2          break;
 351   2          case 100:                       
 352   2          {
 353   3                //CSC[2:0]=[001] ,Fcsck=6.4MHz
 354   3                //IFBW[3:2]=[01],100kHz
 355   3                //SDR[15:9]=0x00,DCK=100Kps
 356   3            A7139_WriteReg(SYSTEMCLOCK_REG,0x0021);
 357   3            A7139_WriteReg(RX1_REG,0x18D4);
 358   3            A7139_WritePageA(TX1_PAGEA,0xF706);
 359   3          }
 360   2          break;
C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 7   

 361   2          case 150:
 362   2          {
 363   3            //Cause LO is 12.8MHz
 364   3            //must use Pll clk gen,complement in detail later
 365   3            //also can be implemented by the users themselves
 366   3            //IFBW=[10] <=> 150kHz
 367   3            //DCK=150K
 368   3            //CSC=000,fcsck=9.6MHz
 369   3            //SDR=0x00
 370   3            //DMOS=1,IFBW=150KHz
 371   3          }
 372   2          break;
 373   2          default:
 374   2                  // set xs[0:0] = 1 to open XTAL
 375   2            A7139_WriteReg(CRYSTAL_REG,A7139Config[CRYSTAL_REG] | 0x0001 );
 376   2            clock_delay_ms(20);
 377   2            return ERR_PARAM;
 378   2        }
 379   1                // set xs[0:0] = 1 to enable XTAL
 380   1        A7139_WriteReg(CRYSTAL_REG,A7139Config[CRYSTAL_REG] | 0x0001 );
 381   1        clock_delay_ms(20);
 382   1        return 0;
 383   1      }
 384          
 385          Uint8 A7139_SetPackLen(Uint8 len)
 386          {
 387   1      //  Uint16 pagVal;
 388   1          Uint16 idata pagVal;
 389   1        A7139_StrobeCmd(CMD_STBY);
 390   1            //FEP[7:0]
 391   1        pagVal = A7139Config_PageA[FIFO_PAGEA] & 0xFF00;
 392   1        A7139_WritePageA(FIFO_PAGEA,pagVal|(len-1));
 393   1            //FEP[13:8]
 394   1        pagVal = A7139Config_PageA[VCB_PAGEA] & 0xC0FF;
 395   1        A7139_WritePageA(VCB_PAGEA,pagVal);
 396   1        return 0;     
 397   1      }
 398          
 399          Uint8 A7139_SetCIDLen(Uint8 len)
 400          {
 401   1        switch(len)
 402   1        {
 403   2          case 2:
 404   2            {
 405   3              A7139_WritePageA(CODE_PAGEA,A7139Config[CODE_PAGEA] & 0xBFFB);
 406   3            }
 407   2            break;
 408   2          case 4:
 409   2            {
 410   3              A7139_WritePageA(CODE_PAGEA,A7139Config[CODE_PAGEA] & 0xBFFB);
 411   3              A7139_WritePageA(CODE_PAGEA,A7139Config[CODE_PAGEA] | 0x0004);
 412   3            }
 413   2            break;
 414   2          default :
 415   2          return ERR_PARAM;
 416   2        }
 417   1        return 0;
 418   1      }
 419          
 420          void A7139_WriteFIFO(Uint8 *buf,Uint8 bufSize)
 421          {
 422   1        A7139_StrobeCmd(CMD_TFR); 
C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 8   

 423   1           clock_delay_ms(1);
 424   1        SCS_OUT(LOW);
 425   1        SPIx_WriteByte(CMD_FIFO_W);
 426   1        while(bufSize--)
 427   1          SPIx_WriteByte(*buf++);
 428   1        SCS_OUT(HIGH);  
 429   1      }
 430          
 431          void A7139_ReadFIFO(Uint8 *buf,Uint8 bufSize)
 432          {
 433   1        A7139_StrobeCmd(CMD_RFR);
 434   1        clock_delay_ms(1);
 435   1        SCS_OUT(LOW);
 436   1        SPIx_WriteByte(CMD_FIFO_R);
 437   1        while(bufSize--)
 438   1          *buf++ = SPIx_ReadByte(); 
 439   1        SCS_OUT(HIGH);               
 440   1      }
 441          
 442          Uint8 A7139_IsBatteryLow(Uint8 low2_x)
 443          {
 444   1      //  Uint16 pagVal;
 445   1          Uint16 idata pagVal;
 446   1        if(low2_x<0x02 || low2_x>0x07)
 447   1          return ERR_PARAM;
 448   1        A7139_StrobeCmd(CMD_STBY);
 449   1            //BVT[3:1] BDS[0:0]
 450   1        pagVal= A7139Config[PM_PAGEA] & 0xFFF0;
 451   1        A7139_WritePageA(PM_PAGEA,pagVal | (low2_x << 1) | 0x01);
 452   1        clock_delay_us(10); //delay 5us at least 
 453   1            //read VBD[7:7]
 454   1        return !((A7139_ReadPageA(WOR1_PAGEA) & 0x0080) >> 7);
 455   1      }
 456          Uint8 A7139_GetRSSI()
 457          { 
 458   1      //  Uint8  rssi;
 459   1      //  Uint16 t_retry = 0xFFFF;
 460   1        Uint8  idata rssi;
 461   1        Uint16 idata t_retry = 0xFFFF;
 462   1          //entry RX mode
 463   1        A7139_StrobeCmd(CMD_RX);  
 464   1            //CDM[8:8] = 0
 465   1        A7139_WriteReg(ADC_REG,A7139Config[ADC_REG] & 0xFEFF);
 466   1            //ADCM[0:0] = 1
 467   1        A7139_WriteReg(MODE_REG,A7139_ReadReg(MODE_REG) | 0x0001);
 468   1        do
 469   1        {
 470   2          rssi = A7139_ReadReg(MODE_REG) & 0x0001; //ADCM auto clear when measurement done
 471   2            
 472   2        }while(t_retry-- && rssi);
 473   1        if(t_retry>0)
 474   1          rssi=(A7139_ReadReg(ADC_REG) & 0x00FF);  //ADC[7:0] is the value of RSSI
 475   1        else
 476   1          rssi = ERR_GET_RSSI;
 477   1        A7139_StrobeCmd(CMD_STBY);
 478   1        return rssi;    
 479   1      }
 480          
 481          Uint8 A7139_WOT(void)
 482          {
 483   1        if(A7139_RCOSC_Cal()==ERR_RCOSC_CAL)
 484   1          return ERR_RCOSC_CAL;
C51 COMPILER V9.54   A7139                                                                 03/08/2017 15:17:00 PAGE 9   

 485   1        A7139_StrobeCmd(CMD_STBY);
 486   1          //GIO1=FSYNC, GIO2=WTR  
 487   1        A7139_WritePageA(GIO_PAGEA, 0x0045);
 488   1          //setup WOT Sleep time
 489   1        A7139_WritePageA(WOR1_PAGEA, 0x027f);
 490   1          //WMODE=1 select WOT function
 491   1        A7139_WriteReg(PIN_REG, A7139Config[PIN_REG] | 0x0400);
 492   1          //WORE=1 to enable WOT function   
 493   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0200);
 494   1        //while(1); //注意此处为死循环，代码只为演示之用，用户必须按业务实际逻辑进行需改
 495   1        return 0;
 496   1      }
 497          Uint8 A7139_WOR_BySync(void)
 498          {
 499   1        A7139_StrobeCmd(CMD_STBY);
 500   1            //GIO1=FSYNC, GIO2=WTR  
 501   1        A7139_WritePageA(GIO_PAGEA, 0x0045);
 502   1            //setup WOR Sleep time and Rx time
 503   1        A7139_WritePageA(WOR1_PAGEA, 0xFC05);
 504   1        if(A7139_RCOSC_Cal()==ERR_RCOSC_CAL)
 505   1          return ERR_RCOSC_CAL;
 506   1            //enable RC OSC & WOR by sync
 507   1        A7139_WritePageA(WOR2_PAGEA, A7139Config_PageA[WOR2_PAGEA] | 0x0010);
 508   1            //WORE=1 to enable WOR function
 509   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0200);
 510   1        
 511   1        //while(GIO1==0);   //Stay in WOR mode until receiving preamble(preamble ok)
 512   1        return 0;
 513   1      }
 514          Uint8 A7139_WOR_ByPreamble(void)
 515          {
 516   1        A7139_StrobeCmd(CMD_STBY);
 517   1        A7139_WritePageA(GIO_PAGEA, 0x004D);  //GIO1=PMDO, GIO2=WTR
 518   1      
 519   1        //Real WOR Active Period = (WOR_AC[5:0]+1) x 244us,XTAL and Regulator Settling Time
 520   1        //Note : Be aware that Xtal settling time requirement includes initial tolerance, 
 521   1        //       temperature drift, aging and crystal loading.
 522   1        A7139_WritePageA(WOR1_PAGEA, 0xFC05); //setup WOR Sleep time and Rx time
 523   1              //RC Oscillator Calibration
 524   1        if(A7139_RCOSC_Cal()==ERR_RCOSC_CAL)
 525   1          return ERR_RCOSC_CAL;
 526   1        A7139_WritePageA(WOR2_PAGEA, A7139Config_PageA[WOR2_PAGEA] | 0x0030); //enable RC OSC & WOR by preamble
 527   1        
 528   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0200);       //WORE=1 to enable WOR function
 529   1        
 530   1        //while(GIO1==0);   //Stay in WOR mode until receiving preamble(preamble ok)
 531   1        return 0;
 532   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2764    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     38    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     41    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
