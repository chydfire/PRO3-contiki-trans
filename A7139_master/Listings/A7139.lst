C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE A7139
OBJECT MODULE PLACED IN .\output\A7139.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\A7139\A7139.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\
                    -source\USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\clock;
                    -.\source\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\A7139.lst) TABS(2) OBJECT(
                    -.\output\A7139.obj)

line level    source

   1          #include "A7139.h"
   2          #define open_led1   P26 = 0
   3          #define close_led1  P26 = 1
   4          #define toggle_led1 P26 = ~P26
   5          #define open_led2   P27 = 0
   6          #define close_led2  P27 = 1
   7          #define toggle_led2 P27 = ~P27
   8          
   9          static void A7139_WriteReg(Uint8 regAddr, Uint16 regVal)
  10          {
  11   1          SCS_OUT(LOW);
  12   1          regAddr |= CMD_Reg_W;
  13   1          SPIx_WriteByte(regAddr);
  14   1          delay_us(1);
  15   1          SPIx_WriteWord(regVal);
  16   1          SCS_OUT(HIGH);
  17   1      }
  18          
  19          static Uint16 A7139_ReadReg(Uint8 regAddr)
  20          {
  21   1      //    Uint16 regVal;
  22   1            Uint16 idata regVal;
  23   1          SCS_OUT(LOW);
  24   1          regAddr |= CMD_Reg_R;
  25   1          SPIx_WriteByte(regAddr);
  26   1          delay_us(1);
  27   1          regVal=SPIx_ReadWord();
  28   1          SCS_OUT(HIGH);
  29   1          return regVal;
  30   1      }
  31          
  32          static void A7139_WritePageA(Uint8 address, Uint16 dataWord)
  33          {
  34   1      //    Uint16 tmp;
  35   1          Uint16 idata tmp;
  36   1          tmp = address;
  37   1          tmp = ((tmp << 12) | A7139Config[CRYSTAL_REG]);
  38   1          A7139_WriteReg(CRYSTAL_REG, tmp);
  39   1          A7139_WriteReg(PAGEA_REG, dataWord);
  40   1      }
  41          
  42          static void A7139_WritePageB(Uint8 address, Uint16 dataWord)
  43          {
  44   1      //    Uint16 tmp;
  45   1          Uint16 idata tmp;
  46   1          tmp = address;
  47   1          tmp = ((tmp << 7) | A7139Config[CRYSTAL_REG]);
  48   1          A7139_WriteReg(CRYSTAL_REG, tmp);
  49   1          A7139_WriteReg(PAGEB_REG, dataWord);
  50   1      }
  51          
  52          static Uint16 A7139_ReadPageA(Uint8 address)
C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 2   

  53          {
  54   1      //    Uint16 tmp;
  55   1          Uint16 idata tmp;
  56   1          tmp = address;
  57   1          tmp = ((tmp << 12) | A7139Config[CRYSTAL_REG]);
  58   1          A7139_WriteReg(CRYSTAL_REG, tmp);
  59   1          tmp = A7139_ReadReg(PAGEA_REG);
  60   1          return tmp;
  61   1      }
  62          
  63          static void A7139_Config(void)
  64          {
  65   1      //  Uint8 i;
  66   1          Uint8 idata i;
  67   1        for(i=0; i<8; i++)
  68   1              A7139_WriteReg(i, A7139Config[i]);
  69   1        for(i=10; i<16; i++)
  70   1              A7139_WriteReg(i, A7139Config[i]);
  71   1           for(i=0; i<16; i++)
  72   1              A7139_WritePageA(i, A7139Config_PageA[i]);
  73   1        for(i=0; i<5; i++)
  74   1              A7139_WritePageB(i, A7139Config_PageB[i]);
  75   1      }
  76          
  77          static Uint8 A7139_Cal(void)
  78          {
  79   1      //  Uint8  fbcf;  //IF Filter
  80   1      //  Uint8  vbcf;  //VCO Current
  81   1      //  Uint8  vccf;  //VCO Band
  82   1      //  Uint16 tmp;
  83   1        Uint8  idata fbcf;  //IF Filter
  84   1        Uint8  idata vbcf;  //VCO Current
  85   1        Uint8  idata vccf;  //VCO Band
  86   1        Uint16 idata tmp;
  87   1        
  88   1        tmp = A7139_ReadReg(TX2_PAGEB);      //read chip id 0x1221
  89   1      
  90   1         /******************************************************************************************************/
  91   1      //   A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0002);      //IF Filter Calibration     
  92   1      //     do{
  93   1      //    tmp = A7139_ReadReg(MODE_REG);
  94   1      //    //wxq add
  95   1      //    delay_ms(100);
  96   1      //     }while(tmp & 0x0002);
  97   1      
  98   1      //     //for check(IF Filter)  
  99   1      //     tmp = A7139_ReadReg(CALIBRATION_REG); 
 100   1      //     fbcf = (tmp>>4) & 0x01;
 101   1      //     if(fbcf)
 102   1      //     {
 103   1      //       //wxq_test  1. IF filter fail
 104   1      //       close_led1;   //close led    
 105   1      //     }
 106   1      //     else
 107   1      //     {
 108   1      //       open_led1;   //open led
 109   1      //     }
 110   1      ////   return 0;//test
 111   1      //   /****************************************************************************************************/
 112   1      
 113   1      //  A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0004);       //VCO Bank Calibration       
 114   1      //  do{
C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 3   

 115   1      //    tmp = A7139_ReadReg(MODE_REG);
 116   1      //  }while(tmp & 0x0004);
 117   1      
 118   1      //   //for check(VCO Bank)
 119   1      //  tmp = A7139_ReadReg(CALIBRATION_REG);
 120   1      //  vbcf = (tmp >>8) & 0x01;
 121   1      //  if(vbcf)
 122   1      //  {
 123   1      //    //wxq_test  2. VCO Bank fail
 124   1      //    close_led1;   //close led 
 125   1      //  }
 126   1      //  else
 127   1      //   {
 128   1      //     open_led1;   //open led 
 129   1      //   }
 130   1      ////   return 0;//test
 131   1      ///*******************************************************************************************************
             -**********************************/
 132   1      //  A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x2800);     //VCO Current Calibration    
 133   1      //  
 134   1      //     do{
 135   1      //    tmp = A7139_ReadReg(MODE_REG);
 136   1      //    //wxq add
 137   1      //    delay_ms(100);
 138   1      //     }while(tmp & 0x0800);
 139   1      
 140   1      //  //for check(VCO Current)
 141   1      //     tmp = A7139_ReadPageA(VCB_PAGEA);
 142   1      //    vccf = (tmp>>4) & 0x01;
 143   1      //    if(vccf)
 144   1      //    {
 145   1      //      //wxq_test  3. VCO Current fail
 146   1      //      close_led1;   //close led 
 147   1      //    }
 148   1      //    else
 149   1      //    {
 150   1      //      open_led1;   //open led 
 151   1      //    }
 152   1      //    return 0;//test
 153   1      /*********************************************************************************************************
             -********************************/
 154   1          
 155   1          
 156   1          //IF calibration procedure @STB state
 157   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0802);     //IF Filter & VCO Current Calibration
 158   1           do{
 159   2          tmp = A7139_ReadReg(MODE_REG);
 160   2           }while(tmp & 0x0802);
 161   1          //for check(IF Filter)
 162   1           tmp = A7139_ReadReg(CALIBRATION_REG);
 163   1           //fb = tmp & 0x0F;
 164   1           //fcd = (tmp>>11) & 0x1F;
 165   1           fbcf = (tmp>>4) & 0x01;
 166   1           if(fbcf)
 167   1           {
 168   2          return ERR_CAL;
 169   2           }
 170   1        //for check(VCO Current)
 171   1           tmp = A7139_ReadPageA(VCB_PAGEA);
 172   1        //vcb = tmp & 0x0F;
 173   1        vccf = (tmp>>4) & 0x01;
 174   1        if(vccf)
C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 4   

 175   1        {
 176   2              return ERR_CAL;
 177   2           }
 178   1          //RSSI Calibration procedure @STB state
 179   1        A7139_WriteReg(ADC_REG, 0x4C00);                  //set ADC average=64
 180   1           A7139_WritePageA(WOR2_PAGEA, 0xF800);                //set RSSC_D=40us and RS_DLY=80us
 181   1        A7139_WritePageA(TX1_PAGEA, A7139Config_PageA[TX1_PAGEA] | 0xE000); //set RC_DLY=1.5ms
 182   1           A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x1000);      //RSSI Calibration
 183   1           do{
 184   2          tmp = A7139_ReadReg(MODE_REG);
 185   2           }while(tmp & 0x1000);
 186   1        A7139_WriteReg(ADC_REG, A7139Config[ADC_REG]);
 187   1           A7139_WritePageA(WOR2_PAGEA, A7139Config_PageA[WOR2_PAGEA]);
 188   1        A7139_WritePageA(TX1_PAGEA, A7139Config_PageA[TX1_PAGEA]);
 189   1          //VCO calibration procedure @STB state
 190   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0004);   //VCO Band Calibration
 191   1        do{
 192   2          tmp = A7139_ReadReg(MODE_REG);
 193   2        }while(tmp & 0x0004);
 194   1          //for check(VCO Band)
 195   1        tmp = A7139_ReadReg(CALIBRATION_REG);
 196   1        //vb = (tmp >>5) & 0x07;
 197   1        vbcf = (tmp >>8) & 0x01;
 198   1        if(vbcf)
 199   1        {
 200   2          return ERR_CAL;
 201   2        }
 202   1        return 0;
 203   1      }
 204          
 205          static void A7139_SetFreq(float rfFreq)
 206          {
 207   1      //   float  divFreq = rfFreq / 12.800f;  
 208   1      //   Uint8  intFreq = (Uint8)(divFreq); //integer part
 209   1      //   float  fltFreq = divFreq - intFreq * 1.000f; //fraction part
 210   1      //   Uint16 fpFreg  = (Uint16)(fltFreq * 65536);  //FP register val
 211   1      //   Uint16 orgVal;
 212   1         float  idata divFreq = rfFreq / 12.800f;  
 213   1         Uint8  idata intFreq = (Uint8)(divFreq); //integer part
 214   1         float  idata fltFreq = divFreq - intFreq * 1.000f; //fraction part
 215   1         Uint16 idata fpFreg  = (Uint16)(fltFreq * 65536);  //FP register val
 216   1         Uint16 idata orgVal;
 217   1         A7139_StrobeCmd(CMD_STBY); //enter stand-by mode
 218   1             //AFC[15:15] = 0
 219   1         orgVal = A7139Config[PLL3_REG] & 0x7FFF;
 220   1         A7139_WriteReg(PLL3_REG,orgVal);
 221   1            //RFC[15:12] = 0000
 222   1         orgVal = A7139Config[PLL6_REG] & 0x0FFF;
 223   1         A7139_WriteReg(PLL6_REG,orgVal);
 224   1          //MD1[12:12]=0,1
 225   1         if(rfFreq < 860) //433-510
 226   1          orgVal = A7139Config[PLL4_REG] & 0xEFFF;
 227   1         else  //868-915
 228   1          orgVal = A7139Config[PLL4_REG] | 0x1000;
 229   1         A7139_WriteReg(PLL4_REG,orgVal);
 230   1            //IP[8:0] = intg
 231   1         orgVal = A7139Config[PLL1_REG] & 0xFF00;
 232   1         A7139_WriteReg(PLL1_REG,orgVal|intFreq);
 233   1            //FP[15:0] =  fpFreg
 234   1         A7139_WriteReg(PLL2_REG,fpFreg); 
 235   1            //FPA[15:0] = 0x0000
 236   1         A7139_WritePageB(IF2_PAGEB,0x0000);  
C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 5   

 237   1      }
 238          
 239          static Uint8 A7139_RCOSC_Cal(void)
 240          {
 241   1      //    Uint8  retry = 0xFF;
 242   1      //    Uint16 calbrtVal,t_retry=0xFFFF;
 243   1          Uint8  idata retry = 0xFF;
 244   1          Uint16 idata calbrtVal,t_retry=0xFFFF;
 245   1              //RCOSC_E[4:4] = 1,enable internal RC Oscillator
 246   1          A7139_WritePageA(WOR2_PAGEA, A7139Config_PageA[WOR2_PAGEA] | 0x0010);
 247   1          do{
 248   2                //ENCAL[0:0] = 1,then start RC OSC Calbrt
 249   2            A7139_WritePageA(WCAL_PAGEA, A7139Config_PageA[WCAL_PAGEA] | 0x0001);
 250   2            do{
 251   3                calbrtVal = A7139_ReadPageA(WCAL_PAGEA) & 0x0001;
 252   3            }while(calbrtVal && t_retry--);
 253   2                //read NUMLH[9:1]
 254   2            calbrtVal = (A7139_ReadPageA(WCAL_PAGEA) & 0x03FF) >> 1;
 255   2            if(calbrtVal>186 && calbrtVal<198)
 256   2               return OK_RCOSC_CAL;
 257   2          }while(retry--);
 258   1          return ERR_RCOSC_CAL;
 259   1      }
 260          
 261          void A7139_StrobeCmd(Uint8 cmd)
 262          {
 263   1          SCS_OUT(LOW);
 264   1          SPIx_WriteByte(cmd);
 265   1          SCS_OUT(HIGH);
 266   1      }
 267          
 268          Uint8 A7139_Init(float rfFreq)
 269          {
 270   1      //  IO_Init();
 271   1        SCS_OUT(HIGH);
 272   1        SCK_OUT(LOW);
 273   1           A7139_StrobeCmd(CMD_RF_RST);   //reset A7139 chip
 274   1      //  Delay_ms(10);
 275   1        delay_ms(10);
 276   1        A7139_Config();     //config A7139 chip
 277   1      //  delay_ms(10);       //for crystal stabilized
 278   1      //  A7139_SetCID(0x3475C58C);  //set CID code
 279   1      //  delay_ms(1);
 280   1      //  A7139_SetFreq(rfFreq);    //set Freq
 281   1      //  delay_ms(10);
 282   1        return A7139_Cal();     //IF and VCO calibration
 283   1      }
*** WARNING C280 IN LINE 268 OF source\USER\A7139\A7139.c: 'rfFreq': unreferenced local variable
 284          
 285          Uint8 A7139_SetCID(Uint32 id)
 286          {
 287   1        SCS_OUT(LOW);
 288   1        SPIx_WriteByte(CMD_CID_W);
 289   1        SPIx_WriteByte((Uint8)(id>>24));
 290   1        SPIx_WriteByte((Uint8)(id>>16));
 291   1        SPIx_WriteByte((Uint8)(id>>8));
 292   1        SPIx_WriteByte((Uint8)id);
 293   1        SCS_OUT(HIGH);
 294   1        return 0;
 295   1      }
 296          
 297          Uint16 A7139_ReadPID(void)
C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 6   

 298          {
 299   1      //  Uint16 pid;
 300   1      //  Uint16 pagAddr = TX2_PAGEB << 7;
 301   1        Uint16 idata pid;
 302   1        Uint16 idata pagAddr = TX2_PAGEB << 7;
 303   1        pagAddr|=A7139Config[CRYSTAL_REG] & 0xF7CF;
 304   1        A7139_WriteReg(CRYSTAL_REG, pagAddr);
 305   1        pid = A7139_ReadReg(PAGEB_REG);
 306   1        return pid;
 307   1      }
 308          
 309          Uint8 A7139_SetDataRate(Uint8 datRate)
 310          {
 311   1          //enter stand by mode
 312   1        A7139_StrobeCmd(CMD_STBY);
 313   1        delay_ms(20);
 314   1            //set xs[0:0] = 0 to disable XTAL
 315   1        A7139_WriteReg(CRYSTAL_REG,A7139Config[CRYSTAL_REG] & 0xFFFE );
 316   1        switch(datRate)
 317   1        {
 318   2          case 2:
 319   2          { 
 320   3                //CSC[2:0]=[001],Fcsck=3.2MHz
 321   3                //IFBW[3:2]=[01],100kHz
 322   3                //SDR[15:9]=0x18,DCK=2Kps,Fdev = 7.8125kHz
 323   3            A7139_WriteReg(SYSTEMCLOCK_REG,0x6621); 
 324   3            A7139_WriteReg(RX1_REG,0x18D4); 
 325   3            A7139_WritePageA(TX1_PAGEA,0xF505);
 326   3          }
 327   2          break;
 328   2          case 10:
 329   2          {
 330   3                //CSC[2:0]=[001],Fcsck=6.4MHz
 331   3                //IFBW[3:2]=[01],100kHz
 332   3                //SDR[15:9]=0x04,DCK=10Kps,Fdev = 37.5kHz
 333   3            A7139_WriteReg(SYSTEMCLOCK_REG,0x01221);          
 334   3            A7139_WriteReg(RX1_REG,0x18D4);
 335   3            A7139_WritePageA(TX1_PAGEA,0xF706);
 336   3          }
 337   2          break;
 338   2          case 50:
 339   2          {
 340   3                //CSC[2:0]=[011],Fcsck=3.2MHz
 341   3                //IFBW[3:2]=[00],50Kps 
 342   3                //SDR[15:9]=0x00,DCK=50kHz,Fdev = 18.75kHz
 343   3            A7139_WriteReg(SYSTEMCLOCK_REG,0x0023);
 344   3            A7139_WriteReg(RX1_REG,0x18D0);
 345   3            A7139_WritePageA(TX1_PAGEA,0xF606);
 346   3          }
 347   2          break;
 348   2          case 100:                       
 349   2          {
 350   3                //CSC[2:0]=[001] ,Fcsck=6.4MHz
 351   3                //IFBW[3:2]=[01],100kHz
 352   3                //SDR[15:9]=0x00,DCK=100Kps
 353   3            A7139_WriteReg(SYSTEMCLOCK_REG,0x0021);
 354   3            A7139_WriteReg(RX1_REG,0x18D4);
 355   3            A7139_WritePageA(TX1_PAGEA,0xF706);
 356   3          }
 357   2          break;
 358   2          case 150:
 359   2          {
C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 7   

 360   3            //Cause LO is 12.8MHz
 361   3            //must use Pll clk gen,complement in detail later
 362   3            //also can be implemented by the users themselves
 363   3            //IFBW=[10] <=> 150kHz
 364   3            //DCK=150K
 365   3            //CSC=000,fcsck=9.6MHz
 366   3            //SDR=0x00
 367   3            //DMOS=1,IFBW=150KHz
 368   3          }
 369   2          break;
 370   2          default:
 371   2                  // set xs[0:0] = 1 to open XTAL
 372   2            A7139_WriteReg(CRYSTAL_REG,A7139Config[CRYSTAL_REG] | 0x0001 );
 373   2            delay_ms(20);
 374   2            return ERR_PARAM;
 375   2        }
 376   1                // set xs[0:0] = 1 to enable XTAL
 377   1        A7139_WriteReg(CRYSTAL_REG,A7139Config[CRYSTAL_REG] | 0x0001 );
 378   1        delay_ms(20);
 379   1        return 0;
 380   1      }
 381          
 382          Uint8 A7139_SetPackLen(Uint8 len)
 383          {
 384   1      //  Uint16 pagVal;
 385   1          Uint16 idata pagVal;
 386   1        A7139_StrobeCmd(CMD_STBY);
 387   1            //FEP[7:0]
 388   1        pagVal = A7139Config_PageA[FIFO_PAGEA] & 0xFF00;
 389   1        A7139_WritePageA(FIFO_PAGEA,pagVal|(len-1));
 390   1            //FEP[13:8]
 391   1        pagVal = A7139Config_PageA[VCB_PAGEA] & 0xC0FF;
 392   1        A7139_WritePageA(VCB_PAGEA,pagVal);
 393   1        return 0;     
 394   1      }
 395          
 396          Uint8 A7139_SetCIDLen(Uint8 len)
 397          {
 398   1        switch(len)
 399   1        {
 400   2          case 2:
 401   2            {
 402   3              A7139_WritePageA(CODE_PAGEA,A7139Config[CODE_PAGEA] & 0xBFFB);
 403   3            }
 404   2            break;
 405   2          case 4:
 406   2            {
 407   3              A7139_WritePageA(CODE_PAGEA,A7139Config[CODE_PAGEA] & 0xBFFB);
 408   3              A7139_WritePageA(CODE_PAGEA,A7139Config[CODE_PAGEA] | 0x0004);
 409   3            }
 410   2            break;
 411   2          default :
 412   2          return ERR_PARAM;
 413   2        }
 414   1        return 0;
 415   1      }
 416          
 417          void A7139_WriteFIFO(Uint8 *buf,Uint8 bufSize)
 418          {
 419   1        A7139_StrobeCmd(CMD_TFR); 
 420   1           delay_ms(1);
 421   1        SCS_OUT(LOW);
C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 8   

 422   1        SPIx_WriteByte(CMD_FIFO_W);
 423   1        while(bufSize--)
 424   1          SPIx_WriteByte(*buf++);
 425   1        SCS_OUT(HIGH);  
 426   1      }
 427          
 428          void A7139_ReadFIFO(Uint8 *buf,Uint8 bufSize)
 429          {
 430   1        A7139_StrobeCmd(CMD_RFR);
 431   1        delay_ms(1);
 432   1        SCS_OUT(LOW);
 433   1        SPIx_WriteByte(CMD_FIFO_R);
 434   1        while(bufSize--)
 435   1          *buf++ = SPIx_ReadByte(); 
 436   1        SCS_OUT(HIGH);               
 437   1      }
 438          
 439          Uint8 A7139_IsBatteryLow(Uint8 low2_x)
 440          {
 441   1      //  Uint16 pagVal;
 442   1          Uint16 idata pagVal;
 443   1        if(low2_x<0x02 || low2_x>0x07)
 444   1          return ERR_PARAM;
 445   1        A7139_StrobeCmd(CMD_STBY);
 446   1            //BVT[3:1] BDS[0:0]
 447   1        pagVal= A7139Config[PM_PAGEA] & 0xFFF0;
 448   1        A7139_WritePageA(PM_PAGEA,pagVal | (low2_x << 1) | 0x01);
 449   1        delay_us(10); //delay 5us at least 
 450   1            //read VBD[7:7]
 451   1        return !((A7139_ReadPageA(WOR1_PAGEA) & 0x0080) >> 7);
 452   1      }
 453          Uint8 A7139_GetRSSI()
 454          { 
 455   1      //  Uint8  rssi;
 456   1      //  Uint16 t_retry = 0xFFFF;
 457   1        Uint8  idata rssi;
 458   1        Uint16 idata t_retry = 0xFFFF;
 459   1          //entry RX mode
 460   1        A7139_StrobeCmd(CMD_RX);  
 461   1            //CDM[8:8] = 0
 462   1        A7139_WriteReg(ADC_REG,A7139Config[ADC_REG] & 0xFEFF);
 463   1            //ADCM[0:0] = 1
 464   1        A7139_WriteReg(MODE_REG,A7139_ReadReg(MODE_REG) | 0x0001);
 465   1        do
 466   1        {
 467   2          rssi = A7139_ReadReg(MODE_REG) & 0x0001; //ADCM auto clear when measurement done
 468   2            
 469   2        }while(t_retry-- && rssi);
 470   1        if(t_retry>0)
 471   1          rssi=(A7139_ReadReg(ADC_REG) & 0x00FF);  //ADC[7:0] is the value of RSSI
 472   1        else
 473   1          rssi = ERR_GET_RSSI;
 474   1        A7139_StrobeCmd(CMD_STBY);
 475   1        return rssi;    
 476   1      }
 477          
 478          Uint8 A7139_WOT(void)
 479          {
 480   1        if(A7139_RCOSC_Cal()==ERR_RCOSC_CAL)
 481   1          return ERR_RCOSC_CAL;
 482   1        A7139_StrobeCmd(CMD_STBY);
 483   1          //GIO1=FSYNC, GIO2=WTR  
C51 COMPILER V9.54   A7139                                                                 03/07/2017 19:19:56 PAGE 9   

 484   1        A7139_WritePageA(GIO_PAGEA, 0x0045);
 485   1          //setup WOT Sleep time
 486   1        A7139_WritePageA(WOR1_PAGEA, 0x027f);
 487   1          //WMODE=1 select WOT function
 488   1        A7139_WriteReg(PIN_REG, A7139Config[PIN_REG] | 0x0400);
 489   1          //WORE=1 to enable WOT function   
 490   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0200);
 491   1        //while(1); //注意此处为死循环，代码只为演示之用，用户必须按业务实际逻辑进行需改
 492   1        return 0;
 493   1      }
 494          Uint8 A7139_WOR_BySync(void)
 495          {
 496   1        A7139_StrobeCmd(CMD_STBY);
 497   1            //GIO1=FSYNC, GIO2=WTR  
 498   1        A7139_WritePageA(GIO_PAGEA, 0x0045);
 499   1            //setup WOR Sleep time and Rx time
 500   1        A7139_WritePageA(WOR1_PAGEA, 0xFC05);
 501   1        if(A7139_RCOSC_Cal()==ERR_RCOSC_CAL)
 502   1          return ERR_RCOSC_CAL;
 503   1            //enable RC OSC & WOR by sync
 504   1        A7139_WritePageA(WOR2_PAGEA, A7139Config_PageA[WOR2_PAGEA] | 0x0010);
 505   1            //WORE=1 to enable WOR function
 506   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0200);
 507   1        
 508   1        //while(GIO1==0);   //Stay in WOR mode until receiving preamble(preamble ok)
 509   1        return 0;
 510   1      }
 511          Uint8 A7139_WOR_ByPreamble(void)
 512          {
 513   1        A7139_StrobeCmd(CMD_STBY);
 514   1        A7139_WritePageA(GIO_PAGEA, 0x004D);  //GIO1=PMDO, GIO2=WTR
 515   1      
 516   1        //Real WOR Active Period = (WOR_AC[5:0]+1) x 244us,XTAL and Regulator Settling Time
 517   1        //Note : Be aware that Xtal settling time requirement includes initial tolerance, 
 518   1        //       temperature drift, aging and crystal loading.
 519   1        A7139_WritePageA(WOR1_PAGEA, 0xFC05); //setup WOR Sleep time and Rx time
 520   1              //RC Oscillator Calibration
 521   1        if(A7139_RCOSC_Cal()==ERR_RCOSC_CAL)
 522   1          return ERR_RCOSC_CAL;
 523   1        A7139_WritePageA(WOR2_PAGEA, A7139Config_PageA[WOR2_PAGEA] | 0x0030); //enable RC OSC & WOR by preamble
 524   1        
 525   1        A7139_WriteReg(MODE_REG, A7139Config[MODE_REG] | 0x0200);       //WORE=1 to enable WOR function
 526   1        
 527   1        //while(GIO1==0);   //Stay in WOR mode until receiving preamble(preamble ok)
 528   1        return 0;
 529   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2711    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     36    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     43    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
