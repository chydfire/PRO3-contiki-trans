C51 COMPILER V9.54   UART                                                                  03/09/2017 18:13:18 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\output\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\USER\uart\uart.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\so
                    -urce\USER\A7139;.\source\USER\timer;.\source\USER\uart;.\source\USER\led;C:\Keil_v5\C51\INC\SONIX;.\source\USER\clock;.\
                    -source\USER\inc;.\source\USER\rtimer;.\source\USER\cmd) DEBUG OBJECTEXTEND PRINT(.\Listings\uart.lst) TABS(2) OBJECT(.\o
                    -utput\uart.obj)

line level    source

   1          
   2          #include "uart.h"
   3          
   4          xdata uint8_t RxBuf[UART_BUF_LEN_MAX] = {0};
   5          xdata uint8_t RxData = 0;
   6          xdata uint8_t UartRxFlag = 0;
   7          xdata uint8_t recv_head=0;
   8          xdata uint8_t recv_tail=0;
   9          
  10          //uart init
  11          void uart_init(void)
  12          {
  13   1        P05  = 1;     //UTX pin set high
  14   1        P0M |= 0x20;  //UTX is output,URX is input
  15   1        
  16   1        SM0 = 0;
  17   1        SM1 = 1;      //mode 1:8-bit uart
  18   1        REN0 = 1;     //uart reception enable
  19   1        
  20   1        switch (Baudrate) 
  21   1        {
  22   2              case BR_9600:
  23   2                  S0RELH = 0x03;
  24   2                  S0RELL = 0x98;      // for baudrate gen
  25   2      
  26   2                  PCON |= 0x80;       // SMOD = 1;    
  27   2                                      // baudrate : 9615
  28   2                  BD = 1;
  29   2                  break;
  30   2              case BR_19200:
  31   2                  S0RELH = 0x03;
  32   2                  S0RELL = 0xCC;      // for baudrate gen
  33   2      
  34   2                  PCON |= 0x80;       // SMOD = 1;    
  35   2                                      // baudrate : 19230
  36   2                  BD = 1;
  37   2                  break;
  38   2              case BR_38400:
  39   2                  S0RELH = 0x03;
  40   2                  S0RELL = 0xE6;      // for baudrate gen
  41   2      
  42   2                  PCON |= 0x80;       // SMOD = 1;    
  43   2                                      // baudrate : 38461
  44   2                  BD = 1;
  45   2                  break;
  46   2              case BR_57600:
  47   2                  S0RELH = 0x03;
  48   2                  S0RELL = 0xEF;      // for baudrate gen
  49   2      
  50   2                  PCON |= 0x80;       // SMOD = 1;    
  51   2                                      // baudrate : 58823
  52   2                  BD = 1;
C51 COMPILER V9.54   UART                                                                  03/09/2017 18:13:18 PAGE 2   

  53   2                  break;
  54   2              case BR_115200:
  55   2                  S0RELH = 0x03;
  56   2                  S0RELL = 0xF7;      // for baudrate gen
  57   2      
  58   2                  PCON |= 0x80;       // SMOD = 1;    
  59   2                                      // baudrate : 111111
  60   2                  BD = 1;
  61   2                  break;
  62   2              default:
  63   2                  // br_9600
  64   2                  S0RELH = 0x03;
  65   2                  S0RELL = 0x98;      // for baudrate gen
  66   2      
  67   2                  PCON |= 0x80;       // SMOD = 1;    
  68   2                                      // baudrate : 9615
  69   2                  BD = 1;
  70   2                  break;
  71   2        }
  72   1        
  73   1        ES0 = 1;   //enable uart interrupt
  74   1        EAL = 1;   //enable golbal interrupt
  75   1      }
  76          
  77          //uart interrupt function
  78          /*************************************************************************************
  79          uart接收命令帧格式（下行）
  80          起始字节 + 同步字节 + 节点地址 + 数据区（2个字节） + CRC校验码高字节 + CRC校验码低字节
  81          0xaa        0xbb      (1 -100)
  82          **************************************************************************************/
  83          void SYSUartInterrupt(void) interrupt ISRUart  // Vector @  0x23
  84          {
  85   1          if(RI0)
  86   1          {
  87   2              register uint8_t next = 0;
  88   2            
  89   2              RI0 = 0;                // Clear receiver flag
  90   2              RB80 = 0;
  91   2      
  92   2              next = (recv_head + 1) % UART_BUF_LEN_MAX;
  93   2              if( next != recv_tail )
  94   2              {
  95   3                  RxBuf[recv_head] = S0BUF;
  96   3                  recv_head = next;
  97   3              }
  98   2          }
  99   1      }
 100          
 101          //UART send one byte function
 102          void uart_send_byte(unsigned char txData)
 103          {
 104   1          S0BUF = txData;
 105   1      
 106   1          while(!TI0);       // wait for end of transmit
 107   1      
 108   1          if (TI0) 
 109   1          {
 110   2              TI0 = 0;
 111   2          }
 112   1      }
 113          
 114          //UART send one byte function
C51 COMPILER V9.54   UART                                                                  03/09/2017 18:13:18 PAGE 3   

 115          void uart_send_byte1(uint8_t txData)
 116          {
 117   1          S0BUF = txData;
 118   1      
 119   1          while(!TI0);       // wait for end of transmit
 120   1      
 121   1          if (TI0) 
 122   1          {
 123   2              TI0 = 0;
 124   2          }
 125   1      }
 126          
 127          //UART send string function
 128          void uart_send_string1(uint8_t *s,unsigned char n)
 129          {
 130   1         unsigned char idata i = 0;
 131   1         for(i=0;i<n;i++)
 132   1         {
 133   2          uart_send_byte1(s[i]);
 134   2         }
 135   1      }
 136          //UART send string function
 137          void uart_send_string(unsigned char *s,unsigned char n)
 138          {
 139   1         unsigned char idata i = 0;
 140   1         for(i=0;i<n;i++)
 141   1         {
 142   2          uart_send_byte(s[i]);
 143   2         }
 144   1      }
 145          //发送一个字符串
 146          void Prints(unsigned char *pd)
 147          {
 148   1        while((*pd) != '\0')
 149   1        {
 150   2          uart_send_byte(*pd);
 151   2          pd++;
 152   2        }
 153   1      }
 154          
 155          unsigned int Get_CRC_Check_Code(unsigned char *s,unsigned int n)
 156          {
 157   1       unsigned char idata i,j;
 158   1       unsigned int  idata CRC_Code = 0xFFFF;
 159   1       for(i=0;i<n;i++)
 160   1       {
 161   2           CRC_Code ^= s[i];
 162   2           for(j=0;j<8;j++)
 163   2           {
 164   3              if(CRC_Code&1)
 165   3              {
 166   4               CRC_Code >>= 1;
 167   4               CRC_Code ^= 0xA001;
 168   4              }
 169   3              else
 170   3              {
 171   4               CRC_Code >>= 1;
 172   4              }
 173   3           }
 174   2       }
 175   1       return CRC_Code;
 176   1      }
C51 COMPILER V9.54   UART                                                                  03/09/2017 18:13:18 PAGE 4   

 177          
 178          
 179          void
 180          uart_writeb(char byte)
 181          {
 182   1          S0BUF = byte;
 183   1      
 184   1          while(!TI0);       // wait for end of transmit
 185   1      
 186   1          if (TI0) 
 187   1          {
 188   2              TI0 = 0;
 189   2          }
 190   1      }
 191          
 192          char
 193          putchar(char c)
 194          {
 195   1        uart_writeb((char) c);
 196   1        return c;
 197   1      }
 198          
 199          char getchar(void)
 200          {
 201   1        register uint8_t p = 0;
 202   1        
 203   1        if(recv_tail != recv_head)
 204   1        {
 205   2            p = RxBuf[recv_tail];
 206   2            recv_tail = (recv_tail + 1) % UART_BUF_LEN_MAX;
 207   2        }
 208   1        
 209   1        return (char)p;
 210   1      }
 211          
 212          uint8_t uart_getchar(void)
 213          {
 214   1        register uint8_t p = 0;
 215   1        
 216   1        if(recv_tail != recv_head)
 217   1        {
 218   2            p = RxBuf[recv_tail];
 219   2            recv_tail = (recv_tail + 1) % UART_BUF_LEN_MAX;
 220   2        }
 221   1        
 222   1        return p;
 223   1      }
 224          
 225          uint8_t avalible(void)
 226          {
 227   1        uint8_t cnt = 0;
 228   1        
 229   1        if(recv_tail < recv_head)
 230   1        {
 231   2           cnt = recv_head - recv_tail;
 232   2        }
 233   1        else if(recv_tail > recv_head)
 234   1        {
 235   2           cnt = UART_BUF_LEN_MAX - recv_tail + recv_head;
 236   2        }
 237   1        
 238   1        return cnt;
C51 COMPILER V9.54   UART                                                                  03/09/2017 18:13:18 PAGE 5   

 239   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    947    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     60    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      6    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
